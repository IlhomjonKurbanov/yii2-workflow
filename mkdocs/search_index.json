{
    "docs": [
        {
            "location": "/", 
            "text": "What is yii2-workflow ?\n\n\nyii2-workflow\n is an extension of the \nYii2 Framework\n, designed to help you manage workflow in your app. It is the successor of \nsimpleWorkflow\n which was developed some years ago for the 1.x version of Yii. Both extensions try to keep thing simple and easy to use. They rely as much as possible on standard Yii2 features like \nEvents\n, \ncomponents\n, \nbehaviors\n, etc.\n\n\nBefore going any further in your reading it is important to understand what yii2-workflow is \nnot\n :\n\n\n\n\nit is not a complete and complex workflow engine\n\n\nit does not provide any UI components (basically it's a \nbehavior\n that you add to your \nActiveRecord\n models)\n\n\nit is not a solution to all your problems (I whish it would though)\n\n\n\n\nRequirements\n\n\nWell, the only requirement here is to have installed the latest version of the \nYii2 Framework\n (or at least a version greater or equal to 2.0.3).\n\n\nHow to install\n\n\nThe preferred way to install this extension is through \ncomposer\n.\n\n\nEither run\n\n\nphp composer.phar require --prefer-dist raoul2000/yii2-workflow \n*\n\n\n\n\n\nor add\n\n\nraoul2000/yii2-workflow\n: \n*\n\n\n\n\n\nto the require section of your \ncomposer.json\n file.\n\n\nWhat's next ?\n\n\nIf you have been using the previous implementation of this extension it could be a good thing to start by reading the \nUpgrade From 1.x\n chapter.\n\n\nIf you want to know more about workflow in general in the features provided by \nyii2-workflow\n in particular, check the \noverview\n chapter.\n\n\nIf you feel like an advanced workflow Expert (more or less), the dive into the \nConcept\n chapter.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-is-yii2-workflow", 
            "text": "yii2-workflow  is an extension of the  Yii2 Framework , designed to help you manage workflow in your app. It is the successor of  simpleWorkflow  which was developed some years ago for the 1.x version of Yii. Both extensions try to keep thing simple and easy to use. They rely as much as possible on standard Yii2 features like  Events ,  components ,  behaviors , etc.  Before going any further in your reading it is important to understand what yii2-workflow is  not  :   it is not a complete and complex workflow engine  it does not provide any UI components (basically it's a  behavior  that you add to your  ActiveRecord  models)  it is not a solution to all your problems (I whish it would though)", 
            "title": "What is yii2-workflow ?"
        }, 
        {
            "location": "/#requirements", 
            "text": "Well, the only requirement here is to have installed the latest version of the  Yii2 Framework  (or at least a version greater or equal to 2.0.3).", 
            "title": "Requirements"
        }, 
        {
            "location": "/#how-to-install", 
            "text": "The preferred way to install this extension is through  composer .  Either run  php composer.phar require --prefer-dist raoul2000/yii2-workflow  *   or add  raoul2000/yii2-workflow :  *   to the require section of your  composer.json  file.", 
            "title": "How to install"
        }, 
        {
            "location": "/#whats-next", 
            "text": "If you have been using the previous implementation of this extension it could be a good thing to start by reading the  Upgrade From 1.x  chapter.  If you want to know more about workflow in general in the features provided by  yii2-workflow  in particular, check the  overview  chapter.  If you feel like an advanced workflow Expert (more or less), the dive into the  Concept  chapter.", 
            "title": "What's next ?"
        }, 
        {
            "location": "/overview/", 
            "text": "About Workflows\n\n\nAccording to wikipedia :\n\n\n\n\nA workflow consists of a sequence of connected steps. It is a depiction of a sequence of operations, declared as work of a person, a group of persons, an organization of staff, or one or more simple or complex mechanisms. Workflow may be seen as any abstraction of real work, segregated in workshare, work split or other types of ordering. For control purposes, workflow may be a view on real work under a chosen aspect, thus serving as a virtual representation of actual work.\n(\nread more on Wikipedia\n)\n\n\n\n\nWorkflows (also called Petri net) is a vast subject and the aim of this document is not to go deeply in the theoretical fields. As described in the next chapter, the \nSimpleWorkflow\n behavior only implements a simple subset of it.  if you are interested in better understanding theoretical basis on the subject, you'll find some \nreferences\n at the end of this page.\n\n\nUse case : a blog\n\n\nTo demonstrate how the workflow concept can be used in a valuable way, let's consider a real life example : a Blog. In a typical blog, you would find a model for Post with a \nstatus\n attribute that accept 3 values defined as class constants (this is how status were implemented on the \"old\" \nyii 1.x demo blog\n).\n\n\nmodels/Post.php\n\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    const STATUS_DRAFT=1;\n    const STATUS_PUBLISHED=2;\n    const STATUS_ARCHIVED=3;\n\n\n\n\nIt is quite obvious that theses values define possible states of a Post instance. Moreover, a set of rules are used to define how posts will evolve among these 3 statuses : when you first create a post, it is defined as being \ndraft\n, then it can be \npublished\n or \narchived\n. A \npublished\n post can become \ndraft\n (it is then unpublished) or be \narchived\n. At last an \narchived\n post can be \npublished\n or become \ndraft\n.\n\n\nWhat we have just described here are possible transitions between different statuses of the Post, and if we try to give a graphical representation to this description, we'll end up with our first (and very simple) workflow.\n\n\n\n\nOur workflow definition is:\n\n\n\n\n3 statuses : \ndraft\n, \npublished\n, \narchived\n\n\n6 possible transitions\n\n\ninitial status : draft\n\n\n\n\nTo handle this very simple workflow, there is not much to do as the user has complete freedom to set a post status : any status can be reached from any other status and in this case, \nthere is no need\n for a dedicated extension that would handle workflow logic...because there is no workflow logic !\n\n\nUse case\u00b2: a multi-user publishing system\n\n\nLet's imagine something a little bit more complex.\n\n\n\n\nOur basic blog is now becoming a multi-user publishing system, where each user is assigned tasks : some are redactors (reporter), some make corrections and layout work (they know CSS), and there is of course a chief editors who is responsible for publication.\n\n\n\n\nIf we want to be able to handle posts in our new publishing system, we must think of a more elaborated workflow that will fit this new organization. First of all, let's imagine what could be a list of statuses for our posts :\n\n\n\n\ndraft\n : a post is always created as draft. This is the \ninitial status\n of all posts\n\n\ncorrection\n : the post is being corrected and layout improvements may also be added\n\n\nready\n : the post is ready to be published but not yet online\n\n\npublished\n : the post is online, available to readers\n\n\narchived\n : the post is not directly available to readers, but can be accessed through the archive section of the site\n\n\n\n\nThat is not enough, we must also define possible transitions between these statuses. These transitions strongly \ndepend on how the work is going to be organized\n, how users of our publishing system will interact with each other. For this example we will imagine the following rules :\n\n\n\n\nA Post must always be \ncorrected\n before \npublication\n\n\nthe chief editor is responsible for publishing and un-publishing posts\n\n\nthe chief editor is responsible for sending a post to \narchive\n\n\n\n\nThat will be enough for this example but of course we could (and probably should) add more business rules. Now, based on what we have just define, here is a possible workflow four our posts :\n\n\n\n\nThe first version of the \"Post workflow\" was very simple, and as each status could reach any other status, there was no need for the developer to make any tests when a Post changed status. With this new version, that's another story ! Some logic must be implemented in order to prevent \nArchived\n post to become \nDraft\n, or \nPublished\n posts to be sent to \nCorrection\n by a redactor.\n\n\nThat is when \nSimpleWorkflow\n can be useful!\n\n\nWorkflow Definition\n\n\nSo we have a nice workflow, let's see how the \nSimpleWorkflowBehavior\n can help in managing our Post models life-cycle inside this workflow. First we must create a definition for our workflow.\n\n\nThe default workflow definition format supported by \nyii2-workflow\n is a PHP array. Basically, you provide a class that contains the method \ngetDefinition()\n, and this method returns the workflow definition as a PHP array.\n\n\nThe class is named \nPostWorkflow\n which is by convention the name of a workflow associated with the \nPost\n model. It is located in \n@app/models\n, the default location where workflow definitions are stored. Note that these conventions and default settings can of course be overloaded with values provided by the developer at initialization (this will be discussed later).\n\n\nLet's see how our workflow definition looks like :\n\n\n@app/models/PostWorkflow.php\n\n\nnamespace app\\models;\n\nclass PostWorkflow implements \\raoul2000\\workflow\\source\\file\\IWorkflowDefinitionProvider\n{\n    public function getDefinition() {\n        return [\n            'initialStatusId' =\n 'draft',\n            'status' =\n [\n                'draft' =\n [\n                    'transition' =\n ['correction']\n                ],\n                'correction' =\n [\n                    'transition' =\n ['draft','ready']\n                ],\n                'ready' =\n [\n                    'transition' =\n ['draft', 'correction', 'published']\n                ],\n                'published' =\n [\n                    'transition' =\n ['ready', 'archived']\n                ],\n                'archived' =\n [\n                    'transition' =\n ['ready']\n                ]\n            ]\n        ];\n    }\n}\n\n\n\n\nIt's quite straightforward to understand isn't it ?  \n\n\nNote that a more condensed array format is also supported, but for this example we will use this one as it allows more customization.\n\n\nAttaching the behavior\n\n\nTo be able to manage our Post model inside the workflow, we must take care about following points :\n\n\n\n\ncheck that the Post inherits from\n \nyii\\base\\Model\n : the \nSimpleWorkflowBehavior\n can only be attached to Model objects and in fact most of the time it will be attached to \n\\yii\\db\\ActiveRecord\n Objects.\n\n\nensure that the Post class include an attribute (or a property) that will be used to store the current status of a post. We will use attribute \nstatus\n with type VARCHAR(40) for our example, but it can be any attribute.\n\n\n\n\nAttaching the behavior to our model is a standard Yii2 operation. For more information on Yii2 Behaviors please refer the \nThe Definitive Guide to Yii2.0\n.\n\n\nPost.php in @app/models\n\n\nnamespace app\\models;\n/**\n * @property integer $id\n * @property string $title\n * @property string $body\n * @property string $status column used to store the status of the post\n */\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className()\n        ];\n    }\n    // ...\n\n\n\n\nWe now have a \nPost\n model with workflow capabilities. Let's see how we can use it.\n\n\nBasic Status Usage\n\n\nAssignment and Initial Status\n\n\nThe first operation you'll probably need to perform is assigning a status to our model. The natural way to do this is by simply assigning a value to the \nstatus\n attribute.\n\n\n$post = new Post();\n$post-\nstatus = 'published';\n\n\n\n\nWhen you assign a value to the \nstatus\n attribute, no verification is done against the workflow and the \nSimpleWorkflowBehavior\n is not event invoked in any way. \nThe status validation occurs when the status attribute is saved\n : at this time only, the post object is considered as really sent to a specific status.\n\n\nThe status validation consists in verifying that the model can perform the transition between its actual status and the value assigned to the \nstatus\n attribute.\n\n\nLet's consider the following code :\n\n\n$post = new Post();\n$post-\nstatus = 'published';\n$post-\nsave();\n\n\n\n\nWhen we run this code, we get an Exception !\n\n\nWorkflow Exception \u2013 raoul2000\\workflow\\base\\WorkflowException\nNot an initial status : PostWorkflow/published (\"PostWorkflow/draft\" expected)\n\n\n\nCould it be more clear ? Ok, maybe it could but let's see in detail what just happened.\n\n\nThe \nSimpleWorkflowBehavior\n enters in action when the Post is saved. At this point it tests if the transitions is possible between the current status (managed internally by the behavior) and the final one (assigned to the \nstatus\n attribute). In our case, there was no current status (the object has just been created) and the final status has been set to \npublished\n, so, from the \nSimpleWorkflowBehavior\n point of view, we are dealing with the following transition :\n\n\nnull -\n 'published'\n\n\n\nThis transition is particular as it happens \nonly when a model enters into a workflow\n. If you remember well, the \nPostWorkflow\n definition above contained a key called \ninitialStatusId\n. This key is used to define the status Id that must be used by any model when entering a workflow. This is a built-in constraint : the first status assigned to a model must be the one defined in the \ninitialStatusId\n key.\n\n\nObviously we didn't comply with this rule as we tried to enter into the workflow through the \npublished\n status and that's why we received an exception advising us to use \nPostWorkflow/draft\n instead.\n\n\nLet's follow this wise advice :\n\n\n$post = new Post();\n$post-\nstatus = 'draft';\n$post-\nsave();\necho 'the status is : ' . $post-\nstatus;\n\n\n\n\nNow our post is saved correctly and the output is.\n\n\nthe status is : PostWorkflow/draft\n\n\n\n\nHey wait ! what's that ? we set the \nstatus\n attribute to \ndraft\n, saved the post and now the value of our \nstatus\n attribute is \nPostWorkflow/draft\n. All right, don't panic, this is just the way the \nSimpleWorkflowBehavior\n has normalized the status id, from its short form (\ndraft\n)\nto its absolute form (\nPostWorkflow/draft\n). We will describe this later in a chapter dedicated to the \nWorkflowSource\n component. For the moment just remember that these 2 forms of writing a status are equivalent.\n\n\nsendToStatus\n\n\nAnother way of assigning a status to our Post model is by using the method \nsendToStatus()\n defined in the \nSimpleWorkflowBehavrior\n behavior. When you use \nsendToStatus()\n it is not required to save the model for the \nSimpleWorkflowBehavrior\n to enter in action. A call to\n\nsendToStatus()\n will perform following tasks :\n\n\n\n\nretrieve the current status (stored internally by the \nSimpleWorkflowBehavior\n)\n\n\nfind a transition between the current status and the one passed as argument\n\n\nif such a transition exists, ensure that it can be used and that it is valid\n\n\non success, apply the transition and update the \nstatus\n attribute owned by the Post model.\n\n\n\n\nNote that \nsendToStatus()\n actually performs the transition : the model leaves it current status and goes to the new one.\n It is equivalent to \nstatus\n attribute assignment and model being saved.\n\n\nIn the example below, the output is the same as before, without having to invoke \nsave()\n.\n\n\n$post = new Post();\n$post-\nsendToStatus('draft');\necho 'the status is : ' . $post-\nstatus;\n\n\n\n\nAnd of course if we try to break the \ninitial status\n rule again, we will also get the same exception as before.\n\n\n$post = new Post();\n$post-\nsendToStatus('published');   // exception is thrown here !\n\n\n\n\nIt is important to remember that by definition, a call to \nsendToStatus()\n does not handle persistence of the model, and it is your responsibility to ensure that the model is saved correctly, when needed.\n\n\nSummary\n\n\nThe \nSimpleWorkflowBehavior\n maintains internally the \nreal\n value of the current model status.\nTo actually change the status of a model you have two options :\n\n\n\n\nassign a value to the \nstatus\n attribute and save (or update) it : the value assigned to the \nstatus\n attribute\nis considered as the end status of the pending transition that will be committed when the \nstatus\n attribute is saved\n\n\ncall  \nsendToStatus('endStatus')\n with the end status as argument : the transition between the \nreal\n status and the one passed as argument is committed immediately.\n\n\n\n\nGetting the Status\n\n\nIf status assignment can be done by assigning a value to the \nstatus\n attribute, getting the status value of a model should not involve accessing this attribute directly but use the method \ngetWorkflowStatus()\n instead. However in certain circumstances, reading the status attribute value is acceptable, but then it is your responsibility to ensure that both values are synchronized.\n\n\ngetWorkflowStatus() vs attribute\n\n\nWhen you call \ngetWorkflowStatus()\n on a model attached to the \nSimpleWorkflowBehavior\n, you will get the instance of the status your model is currently in. The type of the object returned in this case is \n\\raoul2000\\workflow\\base\\Status\n. If your model is not in a workflow, \ngetWorkflowStatus()\n returns NULL.\n\n\n// first save a post in status 'draft'\n$post = new Post();\n$post-\nsendToStatus('draft');\n$post-\nsave();\n\n// now read this post and output its status label\n$post2 = Post::findOne($post-\nid);\necho '(1) the status is : ' . $post2-\ngetWorkflowStatus()-\ngetId();\necho '(2) the status is : ' . $post2-\nstatus;\n\n\n\n\nThe output is :\n\n\n(1) the status is : PostWorkflow/draft\n(2) the status is : PostWorkflow/draft\n\n\n\nSeeing at this result, it is not obvious why we should use the \ngetWorkflowStatus()\n method instead of direct attribute access to get the status of a model. Ok but remember that the \nstatus\n attribute may not contain the actual value of the model's status, until this model is\nsaved (or updated).\n\n\nLet's see that on an example. In the code below, 2 functions are modifying and returning a newly created Post object. The problem is they are both accessing the \nstatus\n attribute assuming it contains the actual status value of the post.\n\n\nfunction foo($post) {\n    // do some fancy stuff here ...\n    if( $post-\nstatus == null) {\n        $post-\nstatus = 'draft';\n    }\n    return $post;\n}\n\nfunction bar($post) {\n    // do even more some fancy stuff here ...\n    if( $post-\nstatus == 'draft'){\n        $post-\nstatus = 'correction';\n    }\n    return $post;\n}\n\n$post = foo(new Post());\n$post = bar($post);\n$post-\nsave();  // keep the faith\n\n\n\n\nCan you guess what happens when the model is saved ?  Well, that's when the \nSimpleWorkflowBehavior\n enter into action, but that's too late... The value of the \nstatus\n attribute is \ncorrection\n and the \nreal\n status value stored internally by the behavior is NULL. From the \nSimpleWorkflowBehavior\n point of view, this post object is trying to enter into a workflow through the \ncorrection\n status and we already know this is not permitted : bang ! Same exception again !\n\n\nWorkflow Exception \u2013 raoul2000\\workflow\\base\\WorkflowException\nNot an initial status : PostWorkflow/published (\"PostWorkflow/draft\" expected)\n\n\n\nThis small example tries to illustrate the danger of using the status attribute to know the actual status of the object. Very much care should be taken when doing this and remember that \nthe value of the status attribute does not always reflect the actual Status of a model\n.\n\n\nBelow is a safe version of the previous example. All access are done through the \nSimpleWorkflowBehavior\n behavior.\n\n\nfunction foo($post) {\n    // test if $post is currently in a workflow\n    if( ! $post-\nhasWorkflowStatus() ) {\n        $post-\nsendToStatus('draft');\n    }\n    return $post;\n}\n\nfunction bar($post) {\n    // note that we use the absolute form of the status Id\n    if( $post-\ngetWorkflowStatus()-\ngetId() == 'PostWorkflow/draft'){\n        $post-\nsendToStatus('correction');\n    }\n    return $post;\n}\n\n$post = foo(new Post());\n$post = bar($post);\n$post-\nsave();\n\n\n\n\nThat being said, if you know what you are doing you can of course use the \nstatus\n attribute directly to perform some operations. In this case remember that when the \nstatus\n value is set by the \nSimpleWorkflowBehavior\n the absolute form of status id is used (e.g workflowId/statusId).\n\n\nWorkflow Tasks\n\n\nBeing able to guarantee that the model status will only use authorized transition is nice, but the \nSimpleWorkflowBehavior\n provides a way to add some logic to workflows. Let's imagine that we want to improve our Publishing System with this new business rule :\n\n\n\n\nWe have noticed that people in charge of correction are not so reactive, which increases the publication delay. They say it's because they never know when a new post is ready to be corrected and so, we decide to improve our Blog by sending an email to all correctors, as soon as a new post is requesting correction.\n\n\n\n\nThis can be achieved very easily by adding a \ntask\n to our workflow, on the transition that goes from the \ndraft\n status to the \ncorrection\n status. In the (incomplete) workflow representation below, this task is symbolized by a little green square attached to the transition.\n\n\n\n\nLet's see how to implement this \nsendMail()\n task and include it in our workflow :\n\n\n@app/models/Post.php\n\n\nuse raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this-\non(\n            WorkflowEvent::afterChangeStatus('PostWorkflow/draft', 'PostWorkflow/correction'),\n            [$this, 'sendMail']\n        );\n    }\n\n    public function sendMail($event)\n    {\n        MailingService::sendMailToCorrector(\n            'A Post is ready for correction',\n            'The post [' . $event-\nsender-\nowner-\ntitle . '] is ready to be corrected.'\n        );      \n    }\n\n\n\n\nIf you know a little bit about \nEvents\n in Yii2, you may have recognized what happens on the \ninit()\n method of our Post model : we have attached an event handler to the event returned by the call to \nWorkflowEvent::afterChangeStatus('PostWorkflow/draft', 'PostWorkflow/correction')\n\nwhich is nothing more than a helper method that creates the actual event name for us.\n\n\nIf you're not familiar with the concept of Event in Yii2, you have a look to the \nYii2 definitive Guide\n.\n\n\nThe Event Model\n\n\nThe \nSimpleWorkflowBehavior\n is built around Yii2 events. Most of the time when something interesting happens in a workflow, an event is fired, and that's your job to decide what to do : catch it and use it or let it go, let it free, \nlet it be\n.\n\n\nThere are workflow events for almost everything :\n\n\n\n\nwhen a model enters in a workflow\n\n\nwhen a model leaves a workflow\n\n\nwhen a model enters in a status\n\n\nwhen a model leaves a status\n\n\n\n\nFor even more control, each event from the above list is split into its \nbefore\n and \nafter\n variation. When working with events, it is important to understand when each one is fired so to choose the appropriate one to perform a task. In the previous example we have declared an \nevent handler\n in charge of sending a mail to the corrector people, when the post changes from status \ndraft\n to \ncorrection\n. That's already something, but it doesn't completely satisfies our requirement which was :\n\n\n\n\n[...] sending an email to all correctors, as soon as a new post is requesting correction.\n\n\n\n\nIf we take a look to our workflow, we can see that there are 2 ways to reach the status \ncorrection\n : one coming from \ndraft\n the other coming from \nready\n... and this last one is not taken into account by the current event handler installed the Post model.\n\n\nWe could of course handle both transitions, but what if tomorrow, a new transition to \ncorrection\n is added ? To be sure to still notify correctors, the proper solution would be to handle the \nenter to status\n event.\n\n\nThe event handler registration now becomes :\n\n\n$this-\non(\n    WorkflowEvent::afterEnterStatus('PostWorkflow/correction'),\n    [$this, 'sendMail']\n);\n\n\n\n\nThe \nAfterEnterStatus\n event is fired each time a models enters into a status, no matter what is its start status. The \nsendMail()\n method will be invoked each time a post model enters into the status \ncorrection\n, \nno matters where it comes from\n.\n\n\nOk, next requirement ! .. yes, we have some business rules to implement in our super great multi-user publishing system ! (I hope you didn't forgot it). One of our rule was :\n\n\n\n\nthe chief editor is responsible for publishing/un-publishing posts\n\n\n\n\nIn our workflow, the only way for a post to reach the \npublished\n status is coming from status \nready\n. The rule above can be turned into something more \"workflow oriented\" like \"\na post can be sent to status 'published' only by a chief editor\n\". Using the appropriate workflow event and\n\nYii2 RBAC\n feature we can easily implement this rule in the Post model.\n\n\nuse raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this-\non(\n            WorkflowEvent::beforeEnterStatus('PostWorkflow/published'),\n            function ($event) {\n                $event-\nisValid = \\Yii::$app-\nuser-\ncan('chief.editor');\n            }\n        );\n    }\n    // .....\n\n\n\n\nAssuming we have created the \nchief.editor\n permission, this event handler only checks if it has been assigned to the current user. If that's not the case, the \n$event\n object \nis set as invalid\n and when this happens in a \nbefore\n event, it interrupts immediately the process of transition validation : \nthe model will not be able to reach the end status\n ( here \npublished\n).\n\n\nYes, you understood well (I hope) : invalidating a \nbefore\n event will block the transition. Events like \nbeforeEnterStatus\n, \nbeforeEnterWorkflow\n, \nbeforeLeaveStatus\n etc .. are concerned but if you do the same thing on \nafterChangeStatus\n for example, nothing will happen, that's too late .. sorry.\n\n\nThere's more than that and events in \nSimpleWorkflow\n is a vas subject that is covered in detailed in \nanother chapter\n.\n\n\nWorkflow Driven Model Validation\n\n\nWhen dealing with complex workflows where model validation rules are strongly related to statuses and user interaction is required, attributes validation can quickly become a nightmare to handle\n\n\nAgain, let's see that on an example.\n\n\n\n\nIn our publishing System, a Post has various attributes : \ncategory\n, \ntags\n, \npriority\n, etc... These attributes are not set at the Post creation but at different moment of its life-cycle in the workflow. For instance, we decide that the author must give a category to the Post, the correction team is in charge of adding tags, and at last the chief editor is responsible for setting a priority to the Post.\n\n\n\n\nIn terms of validation rules for the Post model, this new requirement can be defined by 3 statements :\n\n\n\n\nWhen the Post is sent from \ndraft\n to \ncorrection\n status, it must have a \ncategory\n\n\nWhen the Post enter into status \nready\n, it must have \ntags\n\n\nWhen the Post is sent from \nready\n to \npublished\n status, is must have a \npriority\n\n\n\n\nTheses validation could of course be implemented using the event model we saw in the previous chapter : in the appropriate event handler we would test the appropriate attribute. Ok but why reinventing the wheel when Yii2 provides a great \nModel Validation\n feature ? Why not use it ?\n\n\nSimpleWorkflow\n doesn't only provide a behavior, it also came with a custom validator that will help us in verifying that on a specific transition our model attributes are correct. In the example below, we will check the first rule  : in the \ndraft\n to \ncorrection\n transition, the attribute \ncategory\n is required.\n\n\nuse raoul2000\\workflow\\validation\\WorkflowValidator;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function rules()\n    {\n        return [\n            [['status'], WorkflowValidator::className()],\n            ['name','required',\n                'on' =\n 'from {Post3Workflow/draft} to {Post3Workflow/correction}'],            \n        ];\n    }\n\n\n\n\nIn order to enable workflow driven attribute validation, it is required to use the \nraoul2000\\workflow\\validation\\WorkflowValidator\n validator. When you validate the \nstatus\n attribute, the \nWorkflowValidator\n creates a scenario name based on the transition that is about to occur. Remember that the pending transition is the one that goes from the \nactual\n status of the model (maintained internally by the \nSimpleWorkflowBehavior\n) and the \nfuture\n status (assigned to the \nstatus\n attribute). Once the scenario name is created, the \nWorkflowValidator\n applies all validation rules that matches the scenario.\n\n\nIn the following example, our post instance is first sent to status \ndraft\n using the \nsendToStatus()\n method, and then to 'correction' using \nsave()\n which by default initiates the model validation.\n\n\n$post = new Post();\n$post-\nsendToStatus('draft'); // = success : the current status is 'draft'\n$post-\nstatus = 'correction';\nif( ! $post-\nsave() ) {     // pending transition is draft -\n correction\n    echo $post-\ngetFirstError('name');\n}\n\n\n\n\nThe output :\n\n\nName cannot be blank.\n\n\n\nBased on scenario names which are meaningful in a workflow context, we can define validation rules for any attribute model, just like you would do with any other scenario.\n\n\nread more\n\n\nWorkflow Scenario\n\n\nIn the previous example we have used the \nrequired\n built-in validator on the \nname\n attribute, only for the scenario \nfrom {Post3Workflow/draft} to {Post3Workflow/correction}\n. This scenario name is created automatically at validation time by the \nWorkflowValidator\n depending on the pending transition. In order to provide maximum flexibility there are several scenario like this one which that are created the same way by the \nWorkflowValidator\n.\n\n\n\n\nfrom {start} to {end}\n\n\nleave status {status}\n\n\nenter status {status}\n\n\nenter status {status}\n\n\nenter workflow {workflow id}\n\n\nleave workflow {workflow id}\n\n\n\n\nAs you can see \nSimpleWorkflow\n allows to validate model attributes at different moment of the model life-cycle within a workflow. You could for instance validate that the attribute \ntags\n is not empty when the post model \nenter status {Post3Workflow/ready}\n, or as soon as the post \nenter workflow {Post3Workflow}\n.\n\n\nThe helper class \nWorkflowScenario\n is here to assist you with scenario names, and if your favorite IDE includes a nice auto-completion feature, writing scenario name may become a real pleasure (more or less).\n\n\nLet's rewrite our validation rules using the \nWorkflowScenario\n helper:\n\n\nuse raoul2000\\workflow\\validation\\WorkflowValidator;\nuse raoul2000\\workflow\\validation\\WorkflowScenario;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function rules()\n    {\n        return [\n            [['status'], WorkflowValidator::className()],\n            [\n                'title',\n                'required',\n                'on' =\n WorkflowScenario::changeStatus('Post3Workflow/correction', 'Post3Workflow/ready')\n            ],\n            [\n                'tags',\n                'required',\n                'on' =\n WorkflowScenario::enterStatus('Post3Workflow/ready')\n            ],\n        ];\n    }\n\n\n\n\nLimitation\n\n\nIn the Yii2 Framework, scenario can be used not only to control attribute validation, but also to \ncontrol massive assignment\n. \nThis feature is not available in yii2-workflow extension\n where scenario are only used to select attribute validation rules.\n\n\nReferences\n\n\nThe \nSimpleWorkflow\n behavior, is not dedicated to provide a complete workflow driven model that would replace MVC or any other pattern. It should only be considered as a set of tools that facilitate workflow management for simple applications.\n\n\nIf you want to know more about the subject, and discover what a complete workflow engine looks like, here is a list of interesting links.\n\n\n\n\nAn activity based Workflow Engine for PHP\n\n\nWorkflow Patterns home page\n\n\nGalaxia : an open source workflow engine\n\n\nezComponent : workflow", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#about-workflows", 
            "text": "According to wikipedia :   A workflow consists of a sequence of connected steps. It is a depiction of a sequence of operations, declared as work of a person, a group of persons, an organization of staff, or one or more simple or complex mechanisms. Workflow may be seen as any abstraction of real work, segregated in workshare, work split or other types of ordering. For control purposes, workflow may be a view on real work under a chosen aspect, thus serving as a virtual representation of actual work.\n( read more on Wikipedia )   Workflows (also called Petri net) is a vast subject and the aim of this document is not to go deeply in the theoretical fields. As described in the next chapter, the  SimpleWorkflow  behavior only implements a simple subset of it.  if you are interested in better understanding theoretical basis on the subject, you'll find some  references  at the end of this page.", 
            "title": "About Workflows"
        }, 
        {
            "location": "/overview/#use-case-a-blog", 
            "text": "To demonstrate how the workflow concept can be used in a valuable way, let's consider a real life example : a Blog. In a typical blog, you would find a model for Post with a  status  attribute that accept 3 values defined as class constants (this is how status were implemented on the \"old\"  yii 1.x demo blog ).  models/Post.php  class Post extends \\yii\\db\\ActiveRecord\n{\n    const STATUS_DRAFT=1;\n    const STATUS_PUBLISHED=2;\n    const STATUS_ARCHIVED=3;  It is quite obvious that theses values define possible states of a Post instance. Moreover, a set of rules are used to define how posts will evolve among these 3 statuses : when you first create a post, it is defined as being  draft , then it can be  published  or  archived . A  published  post can become  draft  (it is then unpublished) or be  archived . At last an  archived  post can be  published  or become  draft .  What we have just described here are possible transitions between different statuses of the Post, and if we try to give a graphical representation to this description, we'll end up with our first (and very simple) workflow.   Our workflow definition is:   3 statuses :  draft ,  published ,  archived  6 possible transitions  initial status : draft   To handle this very simple workflow, there is not much to do as the user has complete freedom to set a post status : any status can be reached from any other status and in this case,  there is no need  for a dedicated extension that would handle workflow logic...because there is no workflow logic !", 
            "title": "Use case : a blog"
        }, 
        {
            "location": "/overview/#use-case2-a-multi-user-publishing-system", 
            "text": "Let's imagine something a little bit more complex.   Our basic blog is now becoming a multi-user publishing system, where each user is assigned tasks : some are redactors (reporter), some make corrections and layout work (they know CSS), and there is of course a chief editors who is responsible for publication.   If we want to be able to handle posts in our new publishing system, we must think of a more elaborated workflow that will fit this new organization. First of all, let's imagine what could be a list of statuses for our posts :   draft  : a post is always created as draft. This is the  initial status  of all posts  correction  : the post is being corrected and layout improvements may also be added  ready  : the post is ready to be published but not yet online  published  : the post is online, available to readers  archived  : the post is not directly available to readers, but can be accessed through the archive section of the site   That is not enough, we must also define possible transitions between these statuses. These transitions strongly  depend on how the work is going to be organized , how users of our publishing system will interact with each other. For this example we will imagine the following rules :   A Post must always be  corrected  before  publication  the chief editor is responsible for publishing and un-publishing posts  the chief editor is responsible for sending a post to  archive   That will be enough for this example but of course we could (and probably should) add more business rules. Now, based on what we have just define, here is a possible workflow four our posts :   The first version of the \"Post workflow\" was very simple, and as each status could reach any other status, there was no need for the developer to make any tests when a Post changed status. With this new version, that's another story ! Some logic must be implemented in order to prevent  Archived  post to become  Draft , or  Published  posts to be sent to  Correction  by a redactor.  That is when  SimpleWorkflow  can be useful!", 
            "title": "Use case\u00b2: a multi-user publishing system"
        }, 
        {
            "location": "/overview/#workflow-definition", 
            "text": "So we have a nice workflow, let's see how the  SimpleWorkflowBehavior  can help in managing our Post models life-cycle inside this workflow. First we must create a definition for our workflow.  The default workflow definition format supported by  yii2-workflow  is a PHP array. Basically, you provide a class that contains the method  getDefinition() , and this method returns the workflow definition as a PHP array.  The class is named  PostWorkflow  which is by convention the name of a workflow associated with the  Post  model. It is located in  @app/models , the default location where workflow definitions are stored. Note that these conventions and default settings can of course be overloaded with values provided by the developer at initialization (this will be discussed later).  Let's see how our workflow definition looks like :  @app/models/PostWorkflow.php  namespace app\\models;\n\nclass PostWorkflow implements \\raoul2000\\workflow\\source\\file\\IWorkflowDefinitionProvider\n{\n    public function getDefinition() {\n        return [\n            'initialStatusId' =  'draft',\n            'status' =  [\n                'draft' =  [\n                    'transition' =  ['correction']\n                ],\n                'correction' =  [\n                    'transition' =  ['draft','ready']\n                ],\n                'ready' =  [\n                    'transition' =  ['draft', 'correction', 'published']\n                ],\n                'published' =  [\n                    'transition' =  ['ready', 'archived']\n                ],\n                'archived' =  [\n                    'transition' =  ['ready']\n                ]\n            ]\n        ];\n    }\n}  It's quite straightforward to understand isn't it ?    Note that a more condensed array format is also supported, but for this example we will use this one as it allows more customization.", 
            "title": "Workflow Definition"
        }, 
        {
            "location": "/overview/#attaching-the-behavior", 
            "text": "To be able to manage our Post model inside the workflow, we must take care about following points :   check that the Post inherits from   yii\\base\\Model  : the  SimpleWorkflowBehavior  can only be attached to Model objects and in fact most of the time it will be attached to  \\yii\\db\\ActiveRecord  Objects.  ensure that the Post class include an attribute (or a property) that will be used to store the current status of a post. We will use attribute  status  with type VARCHAR(40) for our example, but it can be any attribute.   Attaching the behavior to our model is a standard Yii2 operation. For more information on Yii2 Behaviors please refer the  The Definitive Guide to Yii2.0 .  Post.php in @app/models  namespace app\\models;\n/**\n * @property integer $id\n * @property string $title\n * @property string $body\n * @property string $status column used to store the status of the post\n */\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className()\n        ];\n    }\n    // ...  We now have a  Post  model with workflow capabilities. Let's see how we can use it.", 
            "title": "Attaching the behavior"
        }, 
        {
            "location": "/overview/#basic-status-usage", 
            "text": "", 
            "title": "Basic Status Usage"
        }, 
        {
            "location": "/overview/#assignment-and-initial-status", 
            "text": "The first operation you'll probably need to perform is assigning a status to our model. The natural way to do this is by simply assigning a value to the  status  attribute.  $post = new Post();\n$post- status = 'published';  When you assign a value to the  status  attribute, no verification is done against the workflow and the  SimpleWorkflowBehavior  is not event invoked in any way.  The status validation occurs when the status attribute is saved  : at this time only, the post object is considered as really sent to a specific status.  The status validation consists in verifying that the model can perform the transition between its actual status and the value assigned to the  status  attribute.  Let's consider the following code :  $post = new Post();\n$post- status = 'published';\n$post- save();  When we run this code, we get an Exception !  Workflow Exception \u2013 raoul2000\\workflow\\base\\WorkflowException\nNot an initial status : PostWorkflow/published (\"PostWorkflow/draft\" expected)  Could it be more clear ? Ok, maybe it could but let's see in detail what just happened.  The  SimpleWorkflowBehavior  enters in action when the Post is saved. At this point it tests if the transitions is possible between the current status (managed internally by the behavior) and the final one (assigned to the  status  attribute). In our case, there was no current status (the object has just been created) and the final status has been set to  published , so, from the  SimpleWorkflowBehavior  point of view, we are dealing with the following transition :  null -  'published'  This transition is particular as it happens  only when a model enters into a workflow . If you remember well, the  PostWorkflow  definition above contained a key called  initialStatusId . This key is used to define the status Id that must be used by any model when entering a workflow. This is a built-in constraint : the first status assigned to a model must be the one defined in the  initialStatusId  key.  Obviously we didn't comply with this rule as we tried to enter into the workflow through the  published  status and that's why we received an exception advising us to use  PostWorkflow/draft  instead.  Let's follow this wise advice :  $post = new Post();\n$post- status = 'draft';\n$post- save();\necho 'the status is : ' . $post- status;  Now our post is saved correctly and the output is.  the status is : PostWorkflow/draft  Hey wait ! what's that ? we set the  status  attribute to  draft , saved the post and now the value of our  status  attribute is  PostWorkflow/draft . All right, don't panic, this is just the way the  SimpleWorkflowBehavior  has normalized the status id, from its short form ( draft )\nto its absolute form ( PostWorkflow/draft ). We will describe this later in a chapter dedicated to the  WorkflowSource  component. For the moment just remember that these 2 forms of writing a status are equivalent.", 
            "title": "Assignment and Initial Status"
        }, 
        {
            "location": "/overview/#sendtostatus", 
            "text": "Another way of assigning a status to our Post model is by using the method  sendToStatus()  defined in the  SimpleWorkflowBehavrior  behavior. When you use  sendToStatus()  it is not required to save the model for the  SimpleWorkflowBehavrior  to enter in action. A call to sendToStatus()  will perform following tasks :   retrieve the current status (stored internally by the  SimpleWorkflowBehavior )  find a transition between the current status and the one passed as argument  if such a transition exists, ensure that it can be used and that it is valid  on success, apply the transition and update the  status  attribute owned by the Post model.   Note that  sendToStatus()  actually performs the transition : the model leaves it current status and goes to the new one.  It is equivalent to  status  attribute assignment and model being saved.  In the example below, the output is the same as before, without having to invoke  save() .  $post = new Post();\n$post- sendToStatus('draft');\necho 'the status is : ' . $post- status;  And of course if we try to break the  initial status  rule again, we will also get the same exception as before.  $post = new Post();\n$post- sendToStatus('published');   // exception is thrown here !  It is important to remember that by definition, a call to  sendToStatus()  does not handle persistence of the model, and it is your responsibility to ensure that the model is saved correctly, when needed.", 
            "title": "sendToStatus"
        }, 
        {
            "location": "/overview/#summary", 
            "text": "The  SimpleWorkflowBehavior  maintains internally the  real  value of the current model status.\nTo actually change the status of a model you have two options :   assign a value to the  status  attribute and save (or update) it : the value assigned to the  status  attribute\nis considered as the end status of the pending transition that will be committed when the  status  attribute is saved  call   sendToStatus('endStatus')  with the end status as argument : the transition between the  real  status and the one passed as argument is committed immediately.", 
            "title": "Summary"
        }, 
        {
            "location": "/overview/#getting-the-status", 
            "text": "If status assignment can be done by assigning a value to the  status  attribute, getting the status value of a model should not involve accessing this attribute directly but use the method  getWorkflowStatus()  instead. However in certain circumstances, reading the status attribute value is acceptable, but then it is your responsibility to ensure that both values are synchronized.", 
            "title": "Getting the Status"
        }, 
        {
            "location": "/overview/#getworkflowstatus-vs-attribute", 
            "text": "When you call  getWorkflowStatus()  on a model attached to the  SimpleWorkflowBehavior , you will get the instance of the status your model is currently in. The type of the object returned in this case is  \\raoul2000\\workflow\\base\\Status . If your model is not in a workflow,  getWorkflowStatus()  returns NULL.  // first save a post in status 'draft'\n$post = new Post();\n$post- sendToStatus('draft');\n$post- save();\n\n// now read this post and output its status label\n$post2 = Post::findOne($post- id);\necho '(1) the status is : ' . $post2- getWorkflowStatus()- getId();\necho '(2) the status is : ' . $post2- status;  The output is :  (1) the status is : PostWorkflow/draft\n(2) the status is : PostWorkflow/draft  Seeing at this result, it is not obvious why we should use the  getWorkflowStatus()  method instead of direct attribute access to get the status of a model. Ok but remember that the  status  attribute may not contain the actual value of the model's status, until this model is\nsaved (or updated).  Let's see that on an example. In the code below, 2 functions are modifying and returning a newly created Post object. The problem is they are both accessing the  status  attribute assuming it contains the actual status value of the post.  function foo($post) {\n    // do some fancy stuff here ...\n    if( $post- status == null) {\n        $post- status = 'draft';\n    }\n    return $post;\n}\n\nfunction bar($post) {\n    // do even more some fancy stuff here ...\n    if( $post- status == 'draft'){\n        $post- status = 'correction';\n    }\n    return $post;\n}\n\n$post = foo(new Post());\n$post = bar($post);\n$post- save();  // keep the faith  Can you guess what happens when the model is saved ?  Well, that's when the  SimpleWorkflowBehavior  enter into action, but that's too late... The value of the  status  attribute is  correction  and the  real  status value stored internally by the behavior is NULL. From the  SimpleWorkflowBehavior  point of view, this post object is trying to enter into a workflow through the  correction  status and we already know this is not permitted : bang ! Same exception again !  Workflow Exception \u2013 raoul2000\\workflow\\base\\WorkflowException\nNot an initial status : PostWorkflow/published (\"PostWorkflow/draft\" expected)  This small example tries to illustrate the danger of using the status attribute to know the actual status of the object. Very much care should be taken when doing this and remember that  the value of the status attribute does not always reflect the actual Status of a model .  Below is a safe version of the previous example. All access are done through the  SimpleWorkflowBehavior  behavior.  function foo($post) {\n    // test if $post is currently in a workflow\n    if( ! $post- hasWorkflowStatus() ) {\n        $post- sendToStatus('draft');\n    }\n    return $post;\n}\n\nfunction bar($post) {\n    // note that we use the absolute form of the status Id\n    if( $post- getWorkflowStatus()- getId() == 'PostWorkflow/draft'){\n        $post- sendToStatus('correction');\n    }\n    return $post;\n}\n\n$post = foo(new Post());\n$post = bar($post);\n$post- save();  That being said, if you know what you are doing you can of course use the  status  attribute directly to perform some operations. In this case remember that when the  status  value is set by the  SimpleWorkflowBehavior  the absolute form of status id is used (e.g workflowId/statusId).", 
            "title": "getWorkflowStatus() vs attribute"
        }, 
        {
            "location": "/overview/#workflow-tasks", 
            "text": "Being able to guarantee that the model status will only use authorized transition is nice, but the  SimpleWorkflowBehavior  provides a way to add some logic to workflows. Let's imagine that we want to improve our Publishing System with this new business rule :   We have noticed that people in charge of correction are not so reactive, which increases the publication delay. They say it's because they never know when a new post is ready to be corrected and so, we decide to improve our Blog by sending an email to all correctors, as soon as a new post is requesting correction.   This can be achieved very easily by adding a  task  to our workflow, on the transition that goes from the  draft  status to the  correction  status. In the (incomplete) workflow representation below, this task is symbolized by a little green square attached to the transition.   Let's see how to implement this  sendMail()  task and include it in our workflow :  @app/models/Post.php  use raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this- on(\n            WorkflowEvent::afterChangeStatus('PostWorkflow/draft', 'PostWorkflow/correction'),\n            [$this, 'sendMail']\n        );\n    }\n\n    public function sendMail($event)\n    {\n        MailingService::sendMailToCorrector(\n            'A Post is ready for correction',\n            'The post [' . $event- sender- owner- title . '] is ready to be corrected.'\n        );      \n    }  If you know a little bit about  Events  in Yii2, you may have recognized what happens on the  init()  method of our Post model : we have attached an event handler to the event returned by the call to  WorkflowEvent::afterChangeStatus('PostWorkflow/draft', 'PostWorkflow/correction') \nwhich is nothing more than a helper method that creates the actual event name for us.  If you're not familiar with the concept of Event in Yii2, you have a look to the  Yii2 definitive Guide .", 
            "title": "Workflow Tasks"
        }, 
        {
            "location": "/overview/#the-event-model", 
            "text": "The  SimpleWorkflowBehavior  is built around Yii2 events. Most of the time when something interesting happens in a workflow, an event is fired, and that's your job to decide what to do : catch it and use it or let it go, let it free,  let it be .  There are workflow events for almost everything :   when a model enters in a workflow  when a model leaves a workflow  when a model enters in a status  when a model leaves a status   For even more control, each event from the above list is split into its  before  and  after  variation. When working with events, it is important to understand when each one is fired so to choose the appropriate one to perform a task. In the previous example we have declared an  event handler  in charge of sending a mail to the corrector people, when the post changes from status  draft  to  correction . That's already something, but it doesn't completely satisfies our requirement which was :   [...] sending an email to all correctors, as soon as a new post is requesting correction.   If we take a look to our workflow, we can see that there are 2 ways to reach the status  correction  : one coming from  draft  the other coming from  ready ... and this last one is not taken into account by the current event handler installed the Post model.  We could of course handle both transitions, but what if tomorrow, a new transition to  correction  is added ? To be sure to still notify correctors, the proper solution would be to handle the  enter to status  event.  The event handler registration now becomes :  $this- on(\n    WorkflowEvent::afterEnterStatus('PostWorkflow/correction'),\n    [$this, 'sendMail']\n);  The  AfterEnterStatus  event is fired each time a models enters into a status, no matter what is its start status. The  sendMail()  method will be invoked each time a post model enters into the status  correction ,  no matters where it comes from .  Ok, next requirement ! .. yes, we have some business rules to implement in our super great multi-user publishing system ! (I hope you didn't forgot it). One of our rule was :   the chief editor is responsible for publishing/un-publishing posts   In our workflow, the only way for a post to reach the  published  status is coming from status  ready . The rule above can be turned into something more \"workflow oriented\" like \" a post can be sent to status 'published' only by a chief editor \". Using the appropriate workflow event and Yii2 RBAC  feature we can easily implement this rule in the Post model.  use raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this- on(\n            WorkflowEvent::beforeEnterStatus('PostWorkflow/published'),\n            function ($event) {\n                $event- isValid = \\Yii::$app- user- can('chief.editor');\n            }\n        );\n    }\n    // .....  Assuming we have created the  chief.editor  permission, this event handler only checks if it has been assigned to the current user. If that's not the case, the  $event  object  is set as invalid  and when this happens in a  before  event, it interrupts immediately the process of transition validation :  the model will not be able to reach the end status  ( here  published ).  Yes, you understood well (I hope) : invalidating a  before  event will block the transition. Events like  beforeEnterStatus ,  beforeEnterWorkflow ,  beforeLeaveStatus  etc .. are concerned but if you do the same thing on  afterChangeStatus  for example, nothing will happen, that's too late .. sorry.  There's more than that and events in  SimpleWorkflow  is a vas subject that is covered in detailed in  another chapter .", 
            "title": "The Event Model"
        }, 
        {
            "location": "/overview/#workflow-driven-model-validation", 
            "text": "When dealing with complex workflows where model validation rules are strongly related to statuses and user interaction is required, attributes validation can quickly become a nightmare to handle  Again, let's see that on an example.   In our publishing System, a Post has various attributes :  category ,  tags ,  priority , etc... These attributes are not set at the Post creation but at different moment of its life-cycle in the workflow. For instance, we decide that the author must give a category to the Post, the correction team is in charge of adding tags, and at last the chief editor is responsible for setting a priority to the Post.   In terms of validation rules for the Post model, this new requirement can be defined by 3 statements :   When the Post is sent from  draft  to  correction  status, it must have a  category  When the Post enter into status  ready , it must have  tags  When the Post is sent from  ready  to  published  status, is must have a  priority   Theses validation could of course be implemented using the event model we saw in the previous chapter : in the appropriate event handler we would test the appropriate attribute. Ok but why reinventing the wheel when Yii2 provides a great  Model Validation  feature ? Why not use it ?  SimpleWorkflow  doesn't only provide a behavior, it also came with a custom validator that will help us in verifying that on a specific transition our model attributes are correct. In the example below, we will check the first rule  : in the  draft  to  correction  transition, the attribute  category  is required.  use raoul2000\\workflow\\validation\\WorkflowValidator;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function rules()\n    {\n        return [\n            [['status'], WorkflowValidator::className()],\n            ['name','required',\n                'on' =  'from {Post3Workflow/draft} to {Post3Workflow/correction}'],            \n        ];\n    }  In order to enable workflow driven attribute validation, it is required to use the  raoul2000\\workflow\\validation\\WorkflowValidator  validator. When you validate the  status  attribute, the  WorkflowValidator  creates a scenario name based on the transition that is about to occur. Remember that the pending transition is the one that goes from the  actual  status of the model (maintained internally by the  SimpleWorkflowBehavior ) and the  future  status (assigned to the  status  attribute). Once the scenario name is created, the  WorkflowValidator  applies all validation rules that matches the scenario.  In the following example, our post instance is first sent to status  draft  using the  sendToStatus()  method, and then to 'correction' using  save()  which by default initiates the model validation.  $post = new Post();\n$post- sendToStatus('draft'); // = success : the current status is 'draft'\n$post- status = 'correction';\nif( ! $post- save() ) {     // pending transition is draft -  correction\n    echo $post- getFirstError('name');\n}  The output :  Name cannot be blank.  Based on scenario names which are meaningful in a workflow context, we can define validation rules for any attribute model, just like you would do with any other scenario.  read more", 
            "title": "Workflow Driven Model Validation"
        }, 
        {
            "location": "/overview/#workflow-scenario", 
            "text": "In the previous example we have used the  required  built-in validator on the  name  attribute, only for the scenario  from {Post3Workflow/draft} to {Post3Workflow/correction} . This scenario name is created automatically at validation time by the  WorkflowValidator  depending on the pending transition. In order to provide maximum flexibility there are several scenario like this one which that are created the same way by the  WorkflowValidator .   from {start} to {end}  leave status {status}  enter status {status}  enter status {status}  enter workflow {workflow id}  leave workflow {workflow id}   As you can see  SimpleWorkflow  allows to validate model attributes at different moment of the model life-cycle within a workflow. You could for instance validate that the attribute  tags  is not empty when the post model  enter status {Post3Workflow/ready} , or as soon as the post  enter workflow {Post3Workflow} .  The helper class  WorkflowScenario  is here to assist you with scenario names, and if your favorite IDE includes a nice auto-completion feature, writing scenario name may become a real pleasure (more or less).  Let's rewrite our validation rules using the  WorkflowScenario  helper:  use raoul2000\\workflow\\validation\\WorkflowValidator;\nuse raoul2000\\workflow\\validation\\WorkflowScenario;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function rules()\n    {\n        return [\n            [['status'], WorkflowValidator::className()],\n            [\n                'title',\n                'required',\n                'on' =  WorkflowScenario::changeStatus('Post3Workflow/correction', 'Post3Workflow/ready')\n            ],\n            [\n                'tags',\n                'required',\n                'on' =  WorkflowScenario::enterStatus('Post3Workflow/ready')\n            ],\n        ];\n    }", 
            "title": "Workflow Scenario"
        }, 
        {
            "location": "/overview/#limitation", 
            "text": "In the Yii2 Framework, scenario can be used not only to control attribute validation, but also to  control massive assignment .  This feature is not available in yii2-workflow extension  where scenario are only used to select attribute validation rules.", 
            "title": "Limitation"
        }, 
        {
            "location": "/concept-overview/", 
            "text": "Generalities\n\n\nyii2-workflow\n is a set on objects dedicated to help managing the life-cycle of an ActiveRecord model within a \nworkflow\n.\n\n\nIt includes :\n\n\n\n\na behavior (\nSimpleWorkflowBehavior\n)\n\n\na Workflow Source Component (\nWorkflowFileSource\n)\n\n\na Validator (\nWorkflowValidator\n)\n\n\nthree event sequence models\n\n\nvarious helpers\n\n\na set of interfaces\n\n\n\n\nyii2-workflow\n can be configure to fit your requirements and if that's not enough, you can extend all classes so to implement your own features.\n\n\nIdentifiers\n\n\nThe \nyii2-workflow\n refers to workflows and statuses using identifiers. The way these identifiers are formatted, depends on the \nWorkflowSource\n components used. For instance if you're working with the default source component (the \nworkflowFileSource\n ), status identifiers will look like this : \nworkflowId/StatusId\n (\nread more\n)\n\n\nInitial Status\n\n\nThe initial status is the first status assigned to a model, that's the \none and only entry point\n into a workflow. Each workflow must have exactly one initial status.\n\n\nFor example, in a workflow dedicated to manage posts, the initial status could be called 'draft' : it usually describes the first state of the post.\n\n\nTransition\n\n\nA transition is a \ndirected\n link between two statuses : the \nstart\n status and the \nend\n status (the words 'source' and 'target' may also be used).\n\n\nFor example, if we define a transition between the status 'draft' and 'published', a post with status 'draft' (the start status) is able to reach status 'published' (the end status), but not the opposite.\n\n\nWorkflow Source\n\n\nThe \nWorkflow Source\n is a component responsible for providing workflow, status and transitions objects based on a formatted workflow definition.\n\n\nA \nWorkflow Source\n component can ready virtually any kind of source. The first release includes the \nWorkflowFileSource\n component : by default this source reads a workflow definition from a PHP array wrapped in a class.\n\n\nRead more about Workflow Source\n\n\nEvents\n\n\nThe \nSimpleWorkflow\n is making use of \nYii2 events\n to allow customization of model behavior. You can attach handlers to these events in order to implement a specific behavior to your model during its life cycle inside the workflow.\n\n\nRead more about events", 
            "title": "Basics"
        }, 
        {
            "location": "/concept-overview/#generalities", 
            "text": "yii2-workflow  is a set on objects dedicated to help managing the life-cycle of an ActiveRecord model within a  workflow .  It includes :   a behavior ( SimpleWorkflowBehavior )  a Workflow Source Component ( WorkflowFileSource )  a Validator ( WorkflowValidator )  three event sequence models  various helpers  a set of interfaces   yii2-workflow  can be configure to fit your requirements and if that's not enough, you can extend all classes so to implement your own features.", 
            "title": "Generalities"
        }, 
        {
            "location": "/concept-overview/#identifiers", 
            "text": "The  yii2-workflow  refers to workflows and statuses using identifiers. The way these identifiers are formatted, depends on the  WorkflowSource  components used. For instance if you're working with the default source component (the  workflowFileSource  ), status identifiers will look like this :  workflowId/StatusId  ( read more )", 
            "title": "Identifiers"
        }, 
        {
            "location": "/concept-overview/#initial-status", 
            "text": "The initial status is the first status assigned to a model, that's the  one and only entry point  into a workflow. Each workflow must have exactly one initial status.  For example, in a workflow dedicated to manage posts, the initial status could be called 'draft' : it usually describes the first state of the post.", 
            "title": "Initial Status"
        }, 
        {
            "location": "/concept-overview/#transition", 
            "text": "A transition is a  directed  link between two statuses : the  start  status and the  end  status (the words 'source' and 'target' may also be used).  For example, if we define a transition between the status 'draft' and 'published', a post with status 'draft' (the start status) is able to reach status 'published' (the end status), but not the opposite.", 
            "title": "Transition"
        }, 
        {
            "location": "/concept-overview/#workflow-source", 
            "text": "The  Workflow Source  is a component responsible for providing workflow, status and transitions objects based on a formatted workflow definition.  A  Workflow Source  component can ready virtually any kind of source. The first release includes the  WorkflowFileSource  component : by default this source reads a workflow definition from a PHP array wrapped in a class.  Read more about Workflow Source", 
            "title": "Workflow Source"
        }, 
        {
            "location": "/concept-overview/#events", 
            "text": "The  SimpleWorkflow  is making use of  Yii2 events  to allow customization of model behavior. You can attach handlers to these events in order to implement a specific behavior to your model during its life cycle inside the workflow.  Read more about events", 
            "title": "Events"
        }, 
        {
            "location": "/concept-events/", 
            "text": "Workflow Events\n\n\nyii2-workflow\n is making use of \nYii2 events\n to allow you to customize the behavior of your models while they are evolving inside workflows.\n\n\nBasically when \nsomething interesting happens\n to a model inside a workflow, an event is fired, or more precisely a \nsequence of events\n is fired.\n\n\nEvent Sequence\n\n\nThe default event sequence used by the \nSimpleWorkflow\n behavior is the \nBasicEventSequence\n available in the namespace \n\\raoul2000\\workflow\\events\n. Below is a list of events fired by this sequence :\n\n\n\n    \n\n        \nworkflow event\n\n        \nBasic Event Sequence\n\n    \n\n    \n\n        \nthe model enters in workflow W1\n\n        \n\n            \n\n                \nbeforeEnterWorkflow{W1}\n\n                \nbeforeEnterStatus{W1/init}\n where 'init' is the initial status Id for the workflow W1\n\n                \nafterEnterWorkflow{W1}\n\n                \nafterEnterStatus{W1/init}\n where 'init' is the initial status Id for the workflow W1\n\n            \n\n        \n\n    \n\n    \n\n        \nthe model goes from status W1/A to W1/B\n\n        \n\n            \n\n                \nbeforeLeaveStatus{W1/A}\n\n                \nbeforeChangeStatusFrom{W1/A}to{W1/B}\n\n                \nbeforeEnterStatus{W1/B}\n\n                \nafterLeaveStatus{W1/A}\n\n                \nafterChangeStatusFrom{W1/A}to{W1/B}\n\n                \nafterEnterStatus{W1/B}\n\n            \n\n        \n\n    \n\n    \n\n        \nthe model leaves the workflow W1\n\n        \n\n            \n\n                \nbeforeLeaveStatus{W1/B}\n where W1/B is the last status Id of the model before it leaves the workflow\n\n                \nbeforeLeaveWorkflow{W1}\n\n                \nafterLeaveStatus{W1/B}\n where W1/B is the last status Id of the model before it leaves the workflow\n\n                \nafterLeaveWorkflow{W1}\n\n            \n\n        \n\n    \n\n\n\n\n\nTwo other event sequences are also available in the same namespace :\n\n\n\n\nReducedEventSequence\n\n\nExtendedEventSequence\n\n\n\n\nOf course you can create your own event sequence if the ones provided don't meet your needs. To do so, simply create a class that implements the \nraoul2000\\workflow\\events\\IEventSequence\n interface (see below).\n\n\nConfiguration\n\n\nWhen the \nSimpleWorkflowBehavior\n is initialized, it tries to get a reference to the \nEvent Sequence Component\n to use. By default this component is assumed to have the id \neventSequence\n. If no such component is available, \nit will create one\n using the \nBasicEventSequence\n class and register it in the Yii2 application so to make it available to other \nSimpleWorkflowBehavior\n.\n\n\nTo summarize :\n\n\n\n\neventSequence\n : default Id of the event sequence component used by the \nSimpleWorkflowBehavior\n\n\nBasicEventSequence\n : default event sequence type\n\n\n\n\nIf for instance you want to use the \nReducedEventSequence\n instead of the default one, you must configure it like you would do for any other Yii2 component.\n\n\n$config = [\n    // ....\n    'components' =\n [\n        // the default event sequence component is configured as a ReducedEventSequence\n        // and not a BasicEventSequence anymore\n        'eventSequence' =\n [\n          'class' =\n '\\raoul2000\\workflow\\events\\ReducedEventSequence',\n        ]\n   // ...\n\n\n\n\nThe \nSimpleWorkflowBehavior\n will then use the configured \neventSequence\n component.\n\n\nYou may also want to use a reduced event sequence for one particular workflow, and the basic event sequence with another ones.\nThis can be easily achieved by configuring the ID of the event sequence component that a \nSimpleWorkflowBehavior\n should use.\n\n\nIn the example below we are first configuring a new component with the ID \nmyReducedEventSequence\n and with type \nReducedEventSequence\n.\n\n\n$config = [\n    // ....\n    'components' =\n [\n        'myReducedEventSequence' =\n [\n          'class' =\n '\\raoul2000\\workflow\\events\\ReducedEventSequence',\n        ]\n   // ...\n\n\n\n\nNow let's tell to the behavior of the Post model that it must use the \nmyReducedEventSequence\n event sequence component configured above\ninstead of the default one.\n\n\nnamespace app\\models;\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =\n \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                'eventSequence' =\n 'myReducedEventSequence'\n            ]\n        ];\n    }\n}\n\n\n\n\nAny other model with a \nSimpleWorkflowBehavior\n will keep using the default Event sequence (\nBasicEventSequence\n) but the Post model will use a specific one (\nReducedEventSequence\n).\n\n\nSimpleWorkflow\n events are enabled by default but can be disabled by setting the \neventSequence\n configuration parameter to NULL when attaching the behavior to the model. In this case as you may expect, no event is fired for this model.\n\n\nnamespace app\\models;\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =\n \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                'eventSequence' =\n null // disable all SimpleWorkflow Events for Post instances\n            ]\n        ];\n    }\n}\n\n\n\n\nEvent Object\n\n\nAll events fired are instances of the \nraoul2000\\workflow\\events\\WorkflowEvent\n class which provides all the method needed to get informations on the event that just occured.\n\n\n\n\ngetStartStatus()\n : returns the Status instance that the model is leaving. If the WorkflowEvent is fired because the model \nenters\n into a workflow, this method returns \nnull\n.\n\n\ngetEndStatus()\n : returns the Status instance that the model is reaching. If the WorkflowEvent is fired because the model \nleaves\n a workflow, this method returns \nnull\n.\n\n\ngetTransition()\n : returns the Transition instance that the model is performing. Note that if the WorkflowEvent is fired because the model \nenters\n or \nleaves\n the workflow, this method returns \nnull\n.\n\n\n\n\nRemember that a \nWorkflowEvent\n object is passed to all attached handlers(see next chapter).\n\n\nEvent Handler\n\n\nA event handler is used to implement a specific process on any of the events in the event sequence. Installing an event handler is a standard operation described in the \nYii2 Definitive Guide\n.\n\n\nIn the example below, we are attaching an handler for the event that is fired when a Post instance goes from the status \ndraft\n to the status \ncorrection\n. When this happens, we have decided to send a mail.\n\n\nuse raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this-\non(\n            'afterChangeStatusFrom{PostWorkflow/draft}to{PostWorkflow/correction}',\n            [$this, 'sendMail']\n        );\n    }\n    // $event is an instance of raoul2000\\workflow\\events\\WorkflowEvent\n    public function sendMail($event)\n    {\n        MailingService::sendMailToCorrector(\n            'A Post is ready for correction',\n            'The post [' . $event-\nsender-\nowner-\ntitle . '] is ready to be corrected.'\n        );      \n    }\n\n\n\n\nbefore vs after\n\n\nEach event fired by the \nSimpleWorkflowBehavior\n can be of 2 types : \nbefore\n or \nafter\n. The difference between these types is that a handler attached to a \nbefore\n event is able to block the transition in progress by \ninvalidating\n the event. This is not possible for a handler attached to a \"after* event. Using this feature it becomes possible to block a transition based on the result of a complex processing.\n\n\nIn the following example, an event handler is attached to be invoked \nbefore\n a Post instance enters into the status 'Post/published'. This handler checks that the user who is performing the action has the appropriate permission and if not it \ninvalidates\n the event : the Post instance will not be able to reach the status 'W1/A', the transition is blocked.\n\n\nuse raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this-\non(\n            'beforeEnterStatus{Post/published}',\n            function ($event) {\n                // if the user doesn't have the current authorization, the transition to 'Post/published' is blocked\n\n                if( \\Yii::$app-\nuser-\ncan('publish.post') == false) {\n                    $event-\ninvalidate(\nyou don't have permission to publish this post\n);\n                }\n            }\n        );\n    }\n    // .....\n\n\n\n\nEvent handlers attached to \nbefore\n events allow you to authorize or forbid a transition based on the result of a custom code execution.\n\n\nStatus Constraint\n\n\nIf you have been using the previous version of \nSimpleWorkflow\n (only compatible with Yii 1.x) you may be familiar with \nStatus Constraint\n.\nA \nStatus Constraint\n is a piece of PHP code associated with a status and evaluated as a logical expression \nbefore a model enters into this status\n : if the evaluation succeeds, the model can enter the status otherwise the transition is blocked and the model remains in its current status (\nread more\n).\n\n\nStatus Constraint\n are \nnot declared anymore as PHP code inside the workflow definition\n like in version 1.x but as event handlers attached to the \nbefore\n event type, just like in the previous example where in fact, we have defined a constraint on the status \nW1/A\n.\n\n\nRemember that an event handler attached to a \nbefore\n event type is able to block the transition by invalidating the event object, and that's exactly what a \nStatus Constraint\n does !\n\n\nWorkflow Tasks\n\n\nJust like \nStatus Constraint\n above, \nWorkflow Task\n is a feature available with the previous version of \nSimpleWorkflow\n.\nTo summarize, a workflow task is a piece of PHP code attached to a transition and executed when the transition is performed by the model ( \nread more\n).\n\n\nSuch feature must now be implemented as an event handler attached to an \nafter\n event and not anymore as PHP code defined in the workflow definition (like it used to be in version 1.x). In a \nprevious chapter\n we have already created a workflow task by\nattaching a handler to the event \nafterChangeStatusFrom{PostWorkflow/draft}to{PostWorkflow/correction}\n : a mail is sent when the model goes from \ndraft\n to \ncorrection\n.\n\n\nGetting The Event Sequence\n\n\nOnce \nSimpleWorkflowBehavior\n is attached to model, it injects several method that you can use directly from a model instance (this is \nstandard Yii2 feature\n). Among these methods, \ngetEventSequence()\n is particularly useful when working with events. This method returns an array describing all the events that will be fired if the model is sent to the status passed as argument. This array has 2 keys : \nbefore\n and \nafter\n. The value of each key is an array of \nraoul2000\\workflow\\events\\WorkflowEvent\n objects representing the event that will be fired before and after the transition.\n\n\nLet's see that on the example below where we assume that the \n$post\n instance in currently in status \nready\n. This snippet is displaying the ordered list of event that will be fired when \n$post\n is sent to status \npublished\n.\n\n\n// $post is assumed to be in status 'ready'\nforeach ($post-\ngetEventSequence('published') as $type =\n $events) {\n    foreach($events as $event) {\n        echo 'type = '.$type. ' event name = '.$event-\nname.'\nbr/\n';\n    }\n}\n\n\n\n\nThe transition we are working on is from \nready\n to \npublished\n. The event sequence used is the default one and here is the output which matches the \nBasicEventSequence\n specifications.\n\n\ntype = before event name = beforeLeaveStatus{PostWorkflow/ready}\ntype = before event name = beforeChangeStatusFrom{PostWorkflow/ready}to{PostWorkflow/published}\ntype = before event name = beforeEnterStatus{PostWorkflow/published}\ntype = after event name = afterLeaveStatus{PostWorkflow/ready}\ntype = after event name = afterChangeStatusFrom{PostWorkflow/ready}to{PostWorkflow/published}\ntype = after event name = afterEnterStatus{PostWorkflow/published}\n\n\n\nRemember that events will be fired in this exact order until the last event or until the event is invalidated by a handler attached to the \nbefore\n events.\n\n\nEvent Name Helper\n\n\nThe class \n\\raoul2000\\workflow\\events\\WorkflowEvent\n includes a set of static method that you can use to easely create workflow event names.\nIt's even more useful if your favorite IDE supports auto-completion ! The example below is equivalent to the previous one except that the event name is created at runtime by a call to \nWorkflowEvent::beforeEnterStatus('W1/A')\n.\n\n\n$this-\non(\n    // use the event helper to generate the event name\n    WorkflowEvent::beforeEnterStatus('W1/A'),\n    function ($event) {\n        // ...\n    }\n);\n\n\n\n\nCreating An Event Sequence\n\n\nWe already know that \nSimpleWorkflow\n includes 3 event sequences, from the most simple to the most \nverbose\n one (the default is the \nBasicEventSequence\n). However, you may want to create your own event sequence if for instance you want to optimize the amount of events\nfired and actually handled by your implementation.\n\n\nTo define your own event sequence you must create a class that implements the \n\\raoul2000\\workflow\\events\\IEventSequence\n interface. There are three methods declared in this interface, each one being invoked at runtime, when a specific event occurs in the workflow :\n\n\n\n\ncreateEnterWorkflowSequence\n : invoked when a model enters into a workflow\n\n\ncreateLeaveWorkflowSequence\n : invoked when a model leaves a workflow\n\n\ncreateChangeStatusSequence\n : invoked when a model changes status\n\n\n\n\nEach method must return an array representing the corresponding sequence of events, grouped in 2 possibles types : \nbefore\n and \nafter\n events. These types are used as keys in the returned array, and values is an array of \nWorkflowEvent\n objects representing\nthe sequence of events.\n\n\nFor example :\n\n\npublic function createEnterWorkflowSequence($initalStatus, $sender)\n{\n    return [\n        'before' =\n [\n            new WorkflowEvent(WorkflowEvent::beforeEnterWorkflow($initalStatus-\ngetWorkflowId()),\n                ['end' =\n $initalStatus,'sender'=\n $sender]\n            ),\n            new WorkflowEvent(WorkflowEvent::beforeEnterStatus($initalStatus-\ngetId()),\n                ['end' =\n $initalStatus,'sender'=\n $sender]\n            )\n        ],\n        'after' =\n [\n            new WorkflowEvent(WorkflowEvent::afterEnterWorkflow($initalStatus-\ngetWorkflowId()),\n                ['end' =\n $initalStatus,'sender' =\n $sender]\n            ),\n            new WorkflowEvent(WorkflowEvent::afterEnterStatus($initalStatus-\ngetId()),\n                ['end' =\n $initalStatus,'sender' =\n $sender]\n            )\n        ]\n    ];\n}\n\n\n\n\nGeneric Events\n\n\nWe have seen in the previous chapters that using an \nEvent Sequence\n you can easely implement a custom behavior for your model evolving into a workflow, by installing\nthe appropriate event handlers: an \nEvent Sequence\n allows you to react to the exact event you need with a thin control. However, if you don't need such precision, you can\nalso use so called \ngeneric events\n.\n\n\nTwo \nGeneric Events\n are always fired by the \nSimpleWorkflowBehavior\n as soon as a model changes status, and this, no matter what \nEvent Sequence\n is configured. In fact\neven if you choose to not use \nEvent Sequence\n, the \nGeneric Events\n are fired, because they are fired by the \nSimpleWorkflowBehavior\n itself, and not by another component (like\nthe event sequence component).\n\n\nThe names of the 2 \nGeneric Events\n are :\n\n\n\n\nEVENT_BEFORE_CHANGE_STATUS : fired each time \nbefore\n a model changes status\n\n\nEVENT_AFTER_CHANGE_STATUS : fired each time \nafter\n a model changes status\n\n\n\n\nThe \nbefore\n and \nafter\n event type follow the same rules as with \nEvent Sequence\n and in particular you can block a transition by invalidating the \nbefore\n event.\n\n\nIn order to identify exactly what just happened to your model inside the workflow, you must test what are the values of the \nstartStatus\n and \nendStatus\n by calling the\ncorresponding \nWorkflowEvent\n methods.\n\n\n\n\ngetStartStatus() == null \n getEndStatus() != null\n : the model is \nentering\n into the workflow\n\n\ngetStartStatus() =! null \n getEndStatus() != null\n : the model is \nchanging\n status\n\n\ngetStartStatus() == null \n getEndStatus() == null\n : the model is \nleaving\n into the workflow", 
            "title": "Events"
        }, 
        {
            "location": "/concept-events/#workflow-events", 
            "text": "yii2-workflow  is making use of  Yii2 events  to allow you to customize the behavior of your models while they are evolving inside workflows.  Basically when  something interesting happens  to a model inside a workflow, an event is fired, or more precisely a  sequence of events  is fired.", 
            "title": "Workflow Events"
        }, 
        {
            "location": "/concept-events/#event-sequence", 
            "text": "The default event sequence used by the  SimpleWorkflow  behavior is the  BasicEventSequence  available in the namespace  \\raoul2000\\workflow\\events . Below is a list of events fired by this sequence :  \n     \n         workflow event \n         Basic Event Sequence \n     \n     \n         the model enters in workflow W1 \n         \n             \n                 beforeEnterWorkflow{W1} \n                 beforeEnterStatus{W1/init}  where 'init' is the initial status Id for the workflow W1 \n                 afterEnterWorkflow{W1} \n                 afterEnterStatus{W1/init}  where 'init' is the initial status Id for the workflow W1 \n             \n         \n     \n     \n         the model goes from status W1/A to W1/B \n         \n             \n                 beforeLeaveStatus{W1/A} \n                 beforeChangeStatusFrom{W1/A}to{W1/B} \n                 beforeEnterStatus{W1/B} \n                 afterLeaveStatus{W1/A} \n                 afterChangeStatusFrom{W1/A}to{W1/B} \n                 afterEnterStatus{W1/B} \n             \n         \n     \n     \n         the model leaves the workflow W1 \n         \n             \n                 beforeLeaveStatus{W1/B}  where W1/B is the last status Id of the model before it leaves the workflow \n                 beforeLeaveWorkflow{W1} \n                 afterLeaveStatus{W1/B}  where W1/B is the last status Id of the model before it leaves the workflow \n                 afterLeaveWorkflow{W1} \n             \n         \n       Two other event sequences are also available in the same namespace :   ReducedEventSequence  ExtendedEventSequence   Of course you can create your own event sequence if the ones provided don't meet your needs. To do so, simply create a class that implements the  raoul2000\\workflow\\events\\IEventSequence  interface (see below).", 
            "title": "Event Sequence"
        }, 
        {
            "location": "/concept-events/#configuration", 
            "text": "When the  SimpleWorkflowBehavior  is initialized, it tries to get a reference to the  Event Sequence Component  to use. By default this component is assumed to have the id  eventSequence . If no such component is available,  it will create one  using the  BasicEventSequence  class and register it in the Yii2 application so to make it available to other  SimpleWorkflowBehavior .  To summarize :   eventSequence  : default Id of the event sequence component used by the  SimpleWorkflowBehavior  BasicEventSequence  : default event sequence type   If for instance you want to use the  ReducedEventSequence  instead of the default one, you must configure it like you would do for any other Yii2 component.  $config = [\n    // ....\n    'components' =  [\n        // the default event sequence component is configured as a ReducedEventSequence\n        // and not a BasicEventSequence anymore\n        'eventSequence' =  [\n          'class' =  '\\raoul2000\\workflow\\events\\ReducedEventSequence',\n        ]\n   // ...  The  SimpleWorkflowBehavior  will then use the configured  eventSequence  component.  You may also want to use a reduced event sequence for one particular workflow, and the basic event sequence with another ones.\nThis can be easily achieved by configuring the ID of the event sequence component that a  SimpleWorkflowBehavior  should use.  In the example below we are first configuring a new component with the ID  myReducedEventSequence  and with type  ReducedEventSequence .  $config = [\n    // ....\n    'components' =  [\n        'myReducedEventSequence' =  [\n          'class' =  '\\raoul2000\\workflow\\events\\ReducedEventSequence',\n        ]\n   // ...  Now let's tell to the behavior of the Post model that it must use the  myReducedEventSequence  event sequence component configured above\ninstead of the default one.  namespace app\\models;\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =  \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                'eventSequence' =  'myReducedEventSequence'\n            ]\n        ];\n    }\n}  Any other model with a  SimpleWorkflowBehavior  will keep using the default Event sequence ( BasicEventSequence ) but the Post model will use a specific one ( ReducedEventSequence ).  SimpleWorkflow  events are enabled by default but can be disabled by setting the  eventSequence  configuration parameter to NULL when attaching the behavior to the model. In this case as you may expect, no event is fired for this model.  namespace app\\models;\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =  \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                'eventSequence' =  null // disable all SimpleWorkflow Events for Post instances\n            ]\n        ];\n    }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/concept-events/#event-object", 
            "text": "All events fired are instances of the  raoul2000\\workflow\\events\\WorkflowEvent  class which provides all the method needed to get informations on the event that just occured.   getStartStatus()  : returns the Status instance that the model is leaving. If the WorkflowEvent is fired because the model  enters  into a workflow, this method returns  null .  getEndStatus()  : returns the Status instance that the model is reaching. If the WorkflowEvent is fired because the model  leaves  a workflow, this method returns  null .  getTransition()  : returns the Transition instance that the model is performing. Note that if the WorkflowEvent is fired because the model  enters  or  leaves  the workflow, this method returns  null .   Remember that a  WorkflowEvent  object is passed to all attached handlers(see next chapter).", 
            "title": "Event Object"
        }, 
        {
            "location": "/concept-events/#event-handler", 
            "text": "A event handler is used to implement a specific process on any of the events in the event sequence. Installing an event handler is a standard operation described in the  Yii2 Definitive Guide .  In the example below, we are attaching an handler for the event that is fired when a Post instance goes from the status  draft  to the status  correction . When this happens, we have decided to send a mail.  use raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this- on(\n            'afterChangeStatusFrom{PostWorkflow/draft}to{PostWorkflow/correction}',\n            [$this, 'sendMail']\n        );\n    }\n    // $event is an instance of raoul2000\\workflow\\events\\WorkflowEvent\n    public function sendMail($event)\n    {\n        MailingService::sendMailToCorrector(\n            'A Post is ready for correction',\n            'The post [' . $event- sender- owner- title . '] is ready to be corrected.'\n        );      \n    }", 
            "title": "Event Handler"
        }, 
        {
            "location": "/concept-events/#before-vs-after", 
            "text": "Each event fired by the  SimpleWorkflowBehavior  can be of 2 types :  before  or  after . The difference between these types is that a handler attached to a  before  event is able to block the transition in progress by  invalidating  the event. This is not possible for a handler attached to a \"after* event. Using this feature it becomes possible to block a transition based on the result of a complex processing.  In the following example, an event handler is attached to be invoked  before  a Post instance enters into the status 'Post/published'. This handler checks that the user who is performing the action has the appropriate permission and if not it  invalidates  the event : the Post instance will not be able to reach the status 'W1/A', the transition is blocked.  use raoul2000\\workflow\\events\\WorkflowEvent;\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function init()\n    {\n        $this- on(\n            'beforeEnterStatus{Post/published}',\n            function ($event) {\n                // if the user doesn't have the current authorization, the transition to 'Post/published' is blocked\n\n                if( \\Yii::$app- user- can('publish.post') == false) {\n                    $event- invalidate( you don't have permission to publish this post );\n                }\n            }\n        );\n    }\n    // .....  Event handlers attached to  before  events allow you to authorize or forbid a transition based on the result of a custom code execution.", 
            "title": "before vs after"
        }, 
        {
            "location": "/concept-events/#status-constraint", 
            "text": "If you have been using the previous version of  SimpleWorkflow  (only compatible with Yii 1.x) you may be familiar with  Status Constraint .\nA  Status Constraint  is a piece of PHP code associated with a status and evaluated as a logical expression  before a model enters into this status  : if the evaluation succeeds, the model can enter the status otherwise the transition is blocked and the model remains in its current status ( read more ).  Status Constraint  are  not declared anymore as PHP code inside the workflow definition  like in version 1.x but as event handlers attached to the  before  event type, just like in the previous example where in fact, we have defined a constraint on the status  W1/A .  Remember that an event handler attached to a  before  event type is able to block the transition by invalidating the event object, and that's exactly what a  Status Constraint  does !", 
            "title": "Status Constraint"
        }, 
        {
            "location": "/concept-events/#workflow-tasks", 
            "text": "Just like  Status Constraint  above,  Workflow Task  is a feature available with the previous version of  SimpleWorkflow .\nTo summarize, a workflow task is a piece of PHP code attached to a transition and executed when the transition is performed by the model (  read more ).  Such feature must now be implemented as an event handler attached to an  after  event and not anymore as PHP code defined in the workflow definition (like it used to be in version 1.x). In a  previous chapter  we have already created a workflow task by\nattaching a handler to the event  afterChangeStatusFrom{PostWorkflow/draft}to{PostWorkflow/correction}  : a mail is sent when the model goes from  draft  to  correction .", 
            "title": "Workflow Tasks"
        }, 
        {
            "location": "/concept-events/#getting-the-event-sequence", 
            "text": "Once  SimpleWorkflowBehavior  is attached to model, it injects several method that you can use directly from a model instance (this is  standard Yii2 feature ). Among these methods,  getEventSequence()  is particularly useful when working with events. This method returns an array describing all the events that will be fired if the model is sent to the status passed as argument. This array has 2 keys :  before  and  after . The value of each key is an array of  raoul2000\\workflow\\events\\WorkflowEvent  objects representing the event that will be fired before and after the transition.  Let's see that on the example below where we assume that the  $post  instance in currently in status  ready . This snippet is displaying the ordered list of event that will be fired when  $post  is sent to status  published .  // $post is assumed to be in status 'ready'\nforeach ($post- getEventSequence('published') as $type =  $events) {\n    foreach($events as $event) {\n        echo 'type = '.$type. ' event name = '.$event- name.' br/ ';\n    }\n}  The transition we are working on is from  ready  to  published . The event sequence used is the default one and here is the output which matches the  BasicEventSequence  specifications.  type = before event name = beforeLeaveStatus{PostWorkflow/ready}\ntype = before event name = beforeChangeStatusFrom{PostWorkflow/ready}to{PostWorkflow/published}\ntype = before event name = beforeEnterStatus{PostWorkflow/published}\ntype = after event name = afterLeaveStatus{PostWorkflow/ready}\ntype = after event name = afterChangeStatusFrom{PostWorkflow/ready}to{PostWorkflow/published}\ntype = after event name = afterEnterStatus{PostWorkflow/published}  Remember that events will be fired in this exact order until the last event or until the event is invalidated by a handler attached to the  before  events.", 
            "title": "Getting The Event Sequence"
        }, 
        {
            "location": "/concept-events/#event-name-helper", 
            "text": "The class  \\raoul2000\\workflow\\events\\WorkflowEvent  includes a set of static method that you can use to easely create workflow event names.\nIt's even more useful if your favorite IDE supports auto-completion ! The example below is equivalent to the previous one except that the event name is created at runtime by a call to  WorkflowEvent::beforeEnterStatus('W1/A') .  $this- on(\n    // use the event helper to generate the event name\n    WorkflowEvent::beforeEnterStatus('W1/A'),\n    function ($event) {\n        // ...\n    }\n);", 
            "title": "Event Name Helper"
        }, 
        {
            "location": "/concept-events/#creating-an-event-sequence", 
            "text": "We already know that  SimpleWorkflow  includes 3 event sequences, from the most simple to the most  verbose  one (the default is the  BasicEventSequence ). However, you may want to create your own event sequence if for instance you want to optimize the amount of events\nfired and actually handled by your implementation.  To define your own event sequence you must create a class that implements the  \\raoul2000\\workflow\\events\\IEventSequence  interface. There are three methods declared in this interface, each one being invoked at runtime, when a specific event occurs in the workflow :   createEnterWorkflowSequence  : invoked when a model enters into a workflow  createLeaveWorkflowSequence  : invoked when a model leaves a workflow  createChangeStatusSequence  : invoked when a model changes status   Each method must return an array representing the corresponding sequence of events, grouped in 2 possibles types :  before  and  after  events. These types are used as keys in the returned array, and values is an array of  WorkflowEvent  objects representing\nthe sequence of events.  For example :  public function createEnterWorkflowSequence($initalStatus, $sender)\n{\n    return [\n        'before' =  [\n            new WorkflowEvent(WorkflowEvent::beforeEnterWorkflow($initalStatus- getWorkflowId()),\n                ['end' =  $initalStatus,'sender'=  $sender]\n            ),\n            new WorkflowEvent(WorkflowEvent::beforeEnterStatus($initalStatus- getId()),\n                ['end' =  $initalStatus,'sender'=  $sender]\n            )\n        ],\n        'after' =  [\n            new WorkflowEvent(WorkflowEvent::afterEnterWorkflow($initalStatus- getWorkflowId()),\n                ['end' =  $initalStatus,'sender' =  $sender]\n            ),\n            new WorkflowEvent(WorkflowEvent::afterEnterStatus($initalStatus- getId()),\n                ['end' =  $initalStatus,'sender' =  $sender]\n            )\n        ]\n    ];\n}", 
            "title": "Creating An Event Sequence"
        }, 
        {
            "location": "/concept-events/#generic-events", 
            "text": "We have seen in the previous chapters that using an  Event Sequence  you can easely implement a custom behavior for your model evolving into a workflow, by installing\nthe appropriate event handlers: an  Event Sequence  allows you to react to the exact event you need with a thin control. However, if you don't need such precision, you can\nalso use so called  generic events .  Two  Generic Events  are always fired by the  SimpleWorkflowBehavior  as soon as a model changes status, and this, no matter what  Event Sequence  is configured. In fact\neven if you choose to not use  Event Sequence , the  Generic Events  are fired, because they are fired by the  SimpleWorkflowBehavior  itself, and not by another component (like\nthe event sequence component).  The names of the 2  Generic Events  are :   EVENT_BEFORE_CHANGE_STATUS : fired each time  before  a model changes status  EVENT_AFTER_CHANGE_STATUS : fired each time  after  a model changes status   The  before  and  after  event type follow the same rules as with  Event Sequence  and in particular you can block a transition by invalidating the  before  event.  In order to identify exactly what just happened to your model inside the workflow, you must test what are the values of the  startStatus  and  endStatus  by calling the\ncorresponding  WorkflowEvent  methods.   getStartStatus() == null   getEndStatus() != null  : the model is  entering  into the workflow  getStartStatus() =! null   getEndStatus() != null  : the model is  changing  status  getStartStatus() == null   getEndStatus() == null  : the model is  leaving  into the workflow", 
            "title": "Generic Events"
        }, 
        {
            "location": "/concept-source/", 
            "text": "Workflow Source\n\n\nThe \nWorkflow Source\n is a Yii2 component dedicated to read the persistent representation of a workflow and provide on demand to the \nSimpleWorkflowBehavior\n, its memory representation in terms of PHP objects.\n\n\nThe main Workflow Source component included in the \nSimpleWorkflow\n package is \nraoul2000\\workflow\\source\\file\\WorkflowFileSource\n. It is designed to process workflow definition stored in a file as a regular PHP Array, a PHP class definition or a Graphml file ( for a detail description, refer to \nWorkflow File Source Component\n).\n\n\nNote that it is possible that in the future, other workflow source component are provided like for instance a \nWorkflowDbSource\n that would read from a database.\n\n\nAbout Workflow Objects\n\n\nThe \nSimpleWorkflow\n manipulates objects to manage workflows. There are 3 basic types of objects that you will meet sooner or later. They are all part of the \nraoul2000\\workflow\\base\n namespace:\n\n\n\n\nStatus\n : implements a status in a workflow\n\n\nTransition\n : implemented a directed transition between 2 statuses\n\n\nWorkflow\n : implement a collection of statuses and transitions\n\n\n\n\nThe main purpose of a Workflow Source component is to turn a workflow definition into a set of Status, Transition and Workflow objects.\n\n\nComponent registration\n\n\nWhen the \nSimpleWorkflowBehavior\n is initialized, it tries to get a reference to the \nWorkflow Source Component\n to use. By default this component is assumed to have the id \nworkflowSource\n. If no such component is available, the \nSimpleWorkflowBehavior\n will \ncreate one\n, with the type \nraoul2000\\workflow\\source\\file\\WorkflowFileSource\n (default) and registers it in the Yii2 application, so to make it available to other instances of \nSimpleWorkflowBehavior\n.\n\n\nThis implies that, unless specified otherwise, by default, all \nSimpleWorkflowBehavior\n are sharing \nthe same Workflow Source component\n.\n\n\nIf you're not familiar with \"application Component\", please refer to the \"\nDefinitive Guide to Yii2\n\"\n\n\nTo summarize :\n\n\n\n\nworkflowSource\n : default Id of the workflow source component used by the \nSimpleWorkflowBehavior\n\n\n\\raoul2000\\workflow\\source\\file\\WorkflowFileSource\n : default workflow source component type\n\n\n\n\nIf for instance you want to use another Workflow Source Component instead of the default one, you must configure it like you would do for any other Yii2 component and use the expected default Id.\n\n\n$config = [\n    // ....\n    'components' =\n [\n        'workflowSource' =\n [\n          'class' =\n '\\my\\own\\component\\SuperCoolWorkflowSource',\n        ]\n   // ...\n\n\n\n\nWith this configuration, all \nSimpleWorkflowBehavior\n are going to use your \nSuperCoolWorkflowSource\n to get Status, Transition and Workflow objects.\n\n\nAnother option is to mix Workflow Source Components and for instance use the default one with all models except for a particular one. To achieve this, simply configure your custom Workflow Source Component under a custom Id. Let's see that on an example:\n\n\n\n\nLet's assume that you have developed a super cool workflow source component, able to read workflow definition from a satellite data stream, live\nfrom deep outer space (if you did so, pull requests are welcome !!). You want to use this source only for the \nSpaceShip\n model in your app, leaving all other models\nwith the default source (PHP class).\n\n\n\n\nTo do so, first declare your workflow source as a Yii2 component :\n\n\n$config = [\n    // ....\n    'components' =\n [\n        // declare your source component under a custom id\n        'mySpaceSource' =\n [\n          'class' =\n '\\my\\own\\component\\AlienWorkflowSource',\n        ]\n   // ...\n\n\n\n\nAnd then use the component \nmySpaceSource\n as Workflow source for the \nSpaceShip\n model only :\n\n\nnamespace app\\models;\nclass SpaceShip extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =\n \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                // SpaceShip will use a specific Workflow Source Component\n                // All other models are using the default one\n                'source' =\n 'mySpaceSource'\n            ]\n        ];\n    }\n}\n\n\n\n\nImplementing Your Own Workflow source\n\n\nYou can create your own Workflow Source Component by implementing the \n\\raoul2000\\workflow\\source\\IWorkflowSource\n interface.", 
            "title": "Source"
        }, 
        {
            "location": "/concept-source/#workflow-source", 
            "text": "The  Workflow Source  is a Yii2 component dedicated to read the persistent representation of a workflow and provide on demand to the  SimpleWorkflowBehavior , its memory representation in terms of PHP objects.  The main Workflow Source component included in the  SimpleWorkflow  package is  raoul2000\\workflow\\source\\file\\WorkflowFileSource . It is designed to process workflow definition stored in a file as a regular PHP Array, a PHP class definition or a Graphml file ( for a detail description, refer to  Workflow File Source Component ).  Note that it is possible that in the future, other workflow source component are provided like for instance a  WorkflowDbSource  that would read from a database.", 
            "title": "Workflow Source"
        }, 
        {
            "location": "/concept-source/#about-workflow-objects", 
            "text": "The  SimpleWorkflow  manipulates objects to manage workflows. There are 3 basic types of objects that you will meet sooner or later. They are all part of the  raoul2000\\workflow\\base  namespace:   Status  : implements a status in a workflow  Transition  : implemented a directed transition between 2 statuses  Workflow  : implement a collection of statuses and transitions   The main purpose of a Workflow Source component is to turn a workflow definition into a set of Status, Transition and Workflow objects.", 
            "title": "About Workflow Objects"
        }, 
        {
            "location": "/concept-source/#component-registration", 
            "text": "When the  SimpleWorkflowBehavior  is initialized, it tries to get a reference to the  Workflow Source Component  to use. By default this component is assumed to have the id  workflowSource . If no such component is available, the  SimpleWorkflowBehavior  will  create one , with the type  raoul2000\\workflow\\source\\file\\WorkflowFileSource  (default) and registers it in the Yii2 application, so to make it available to other instances of  SimpleWorkflowBehavior .  This implies that, unless specified otherwise, by default, all  SimpleWorkflowBehavior  are sharing  the same Workflow Source component .  If you're not familiar with \"application Component\", please refer to the \" Definitive Guide to Yii2 \"  To summarize :   workflowSource  : default Id of the workflow source component used by the  SimpleWorkflowBehavior  \\raoul2000\\workflow\\source\\file\\WorkflowFileSource  : default workflow source component type   If for instance you want to use another Workflow Source Component instead of the default one, you must configure it like you would do for any other Yii2 component and use the expected default Id.  $config = [\n    // ....\n    'components' =  [\n        'workflowSource' =  [\n          'class' =  '\\my\\own\\component\\SuperCoolWorkflowSource',\n        ]\n   // ...  With this configuration, all  SimpleWorkflowBehavior  are going to use your  SuperCoolWorkflowSource  to get Status, Transition and Workflow objects.  Another option is to mix Workflow Source Components and for instance use the default one with all models except for a particular one. To achieve this, simply configure your custom Workflow Source Component under a custom Id. Let's see that on an example:   Let's assume that you have developed a super cool workflow source component, able to read workflow definition from a satellite data stream, live\nfrom deep outer space (if you did so, pull requests are welcome !!). You want to use this source only for the  SpaceShip  model in your app, leaving all other models\nwith the default source (PHP class).   To do so, first declare your workflow source as a Yii2 component :  $config = [\n    // ....\n    'components' =  [\n        // declare your source component under a custom id\n        'mySpaceSource' =  [\n          'class' =  '\\my\\own\\component\\AlienWorkflowSource',\n        ]\n   // ...  And then use the component  mySpaceSource  as Workflow source for the  SpaceShip  model only :  namespace app\\models;\nclass SpaceShip extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =  \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                // SpaceShip will use a specific Workflow Source Component\n                // All other models are using the default one\n                'source' =  'mySpaceSource'\n            ]\n        ];\n    }\n}", 
            "title": "Component registration"
        }, 
        {
            "location": "/concept-source/#implementing-your-own-workflow-source", 
            "text": "You can create your own Workflow Source Component by implementing the  \\raoul2000\\workflow\\source\\IWorkflowSource  interface.", 
            "title": "Implementing Your Own Workflow source"
        }, 
        {
            "location": "/concept-validation/", 
            "text": "Workflow Driven Attribute Validation\n\n\nThe \nSimpleWorkflow\n behavior provides a way to apply a specific set of validation rules to model attributes, depending on the way the model is \nmoving\n inside a workflow. This allows you for instance to apply a set of validation rules only when the model goes from a specific status to another one.\n\n\nPrinciples\n\n\nThe \nWorkflow Driven Attribute Validation\n is making use of standard Yii2 features : \"\nUser Input Validation\n\"\nand \"\nScenario\n\".\n\n\nTo implement \nWorkflow Driven Attribute Validation\n you must :\n\n\n\n\ndeclare the \nWorkflowValidator\n validation rule for the attribute used to store the status (by default \nstatus\n)\n\n\ndeclare the validation rules you need and set the \nworkflow scenario name\n for which they should be applied.\n\n\n\n\nThe \nWorkflow Scenario Name\n is a formatted string identitying the event that occurs on the model inside its workflow.\n\n\nBelow is a list of currently supported scenario names :\n\n\n\n    \n\n        \nScenario name template\n\n        \nDescription\n\n    \n\n    \n\n        \n`from {W1/S1} to {W1/S2}`\n\n        \nthe model goes from status S1 to status S2 in workflow W1\n\n    \n\n    \n\n        \n`leave status {W1/S1}`\n\n        \nthe model leaves the status S1 in workflow W1\n\n    \n\n    \n\n        \n`enter status {W1/S1}`\n\n        \nthe model enters into the status S1 in workflow W1\n\n    \n\n    \n\n        \n`enter workflow {W1}`\n\n        \nthe model enters into workflow W1\n\n    \n\n    \n\n        \n`leave workflow {W1}`\n\n        \nthe model leaves workflow W1\n\n    \n\n\n\n\n\nAs you can see, scenario names are quite self explanatory ! To assist you in using workflow scenario names, you can use the class \nraoul2000\\workflow\\validation\\WorkflowScenario\n.\n\n\nFor instance :\n\n\necho WorkflowScenario::changeStatus('W1/S1','W1/S2');   // \nfrom {W1/S1} to {W1/S2}\n\necho WorkflowScenario::leaveStatus('W1/S1');            // \nleave status {W1/S1}\n\necho WorkflowScenario::enterStatus('W1/S1');            // \nenter status {W1/S1}\n\necho WorkflowScenario::enterWorkflow('W1');             // \nenter workflow {W1}\n\necho WorkflowScenario::leaveWorkflow('W1');             // \nleave workflow {W1}\n\n\n\n\n\nUsage example\n\n\nIn the example below we are defining several validation rules applied to the model during its life-cycle through the workflow it is assigned to.\n\n\nuse raoul2000\\workflow\\validation\\WorkflowValidator;\n/**\n * @property integer $id\n * @property string $col_status\n * @property string $title\n * @property string $body\n * @property string $category\n * @property string $tags\n */\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        // declare the SimpleWorkflowBehavior.\n        return [\n            'workflow' =\n [\n                'class' =\n \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                'defaultWorkflowId'      =\n 'post',\n                'statusAttribute'        =\n 'col_status',\n                'propagateErrorsToModel' =\n true\n            ]\n        ];\n    }\n\n    public function rules()\n    {\n        return [\n            [['col_status'],raoul2000\\workflow\\validation\\WorkflowValidator::className()],\n\n            // rule 1 :  the 'title' is always required\n            ['title','required'],\n\n            // rule 2 : the 'body' is required when the post is about to enter to 'post/correction'\n            [['body'],'required',\n                'on' =\n 'enter status {post/correction}'],\n\n            // rule 3 : 'category' is set during correction and before publication\n            ['category', 'required',\n                'on' =\n 'from {post/correction} to {post/published}'\n\n            // rule 4 : 'tags' and 'category' are required before being published or archived.\n            [['tags', 'category'], 'required',\n                'on' =\n ['enter status {post/published}', 'enter status {post/archived}']\n            ],          \n        ];\n    }\n\n\n\n\nIn the above example we have defined a \nPost\n model and configured validation rules to implement the following (imaginary) business rules :\n\n\n\n\nrule n\u00b01 : a post must always have a title\n : that's a standard one, no workflow magic here\n\n\nrule n\u00b02 : redactors are not allowed to send a empty post to correction\n : attribute \nbody\n is required when the post enters into status \npost/correction\n\n\nrule n\u00b03 : correctors are responsible for setting a category to all post before publishing it\n : when a post leaves the 'post/correction\n status to go to\n\npost/published* it must have the \ncategory\n attribute set.\n\n\nrule n\u00b04 : it is forbidden to publish or archive a post with no tags or no category\n : attributes \ntags\n and \ncategory\n cannot be empty when the post\nenter into status \npost/published\n or \npost/archived\n.\n\n\n\n\nImplementation\n\n\nSo how does this works ? As you may have guessed, the entry point is the \nWorkflowValidator\n validator configured for the \nstatus\n attribute.\nThis validator is not actually going to validate the attribute it is configured for ! Yes, believe it or not, this validator doesn't care about the current status value or if the model is about to perform a transition that is not permitted : validating transitions is done by the \nSimpleWorkflowBehavior\n itself, when the model is saved (or when you explicitly invoke \nsendToStatus()\n on the model) and not by the \nWorkflowValidator\n validator.\n\n\nWhen a model is validated, following occurs :\n\n\n\n\nWorkflowValidator\n identifies the pending transition by looking at the \nstatus\n attribute value and the current Status\n\n\nBased on the pending transition, get a \nscenario sequence\n\n\nfor each scenario in the scenario sequence, apply corresponding validating rules", 
            "title": "Validation"
        }, 
        {
            "location": "/concept-validation/#workflow-driven-attribute-validation", 
            "text": "The  SimpleWorkflow  behavior provides a way to apply a specific set of validation rules to model attributes, depending on the way the model is  moving  inside a workflow. This allows you for instance to apply a set of validation rules only when the model goes from a specific status to another one.", 
            "title": "Workflow Driven Attribute Validation"
        }, 
        {
            "location": "/concept-validation/#principles", 
            "text": "The  Workflow Driven Attribute Validation  is making use of standard Yii2 features : \" User Input Validation \"\nand \" Scenario \".  To implement  Workflow Driven Attribute Validation  you must :   declare the  WorkflowValidator  validation rule for the attribute used to store the status (by default  status )  declare the validation rules you need and set the  workflow scenario name  for which they should be applied.   The  Workflow Scenario Name  is a formatted string identitying the event that occurs on the model inside its workflow.  Below is a list of currently supported scenario names :  \n     \n         Scenario name template \n         Description \n     \n     \n         `from {W1/S1} to {W1/S2}` \n         the model goes from status S1 to status S2 in workflow W1 \n     \n     \n         `leave status {W1/S1}` \n         the model leaves the status S1 in workflow W1 \n     \n     \n         `enter status {W1/S1}` \n         the model enters into the status S1 in workflow W1 \n     \n     \n         `enter workflow {W1}` \n         the model enters into workflow W1 \n     \n     \n         `leave workflow {W1}` \n         the model leaves workflow W1 \n       As you can see, scenario names are quite self explanatory ! To assist you in using workflow scenario names, you can use the class  raoul2000\\workflow\\validation\\WorkflowScenario .  For instance :  echo WorkflowScenario::changeStatus('W1/S1','W1/S2');   //  from {W1/S1} to {W1/S2} \necho WorkflowScenario::leaveStatus('W1/S1');            //  leave status {W1/S1} \necho WorkflowScenario::enterStatus('W1/S1');            //  enter status {W1/S1} \necho WorkflowScenario::enterWorkflow('W1');             //  enter workflow {W1} \necho WorkflowScenario::leaveWorkflow('W1');             //  leave workflow {W1}", 
            "title": "Principles"
        }, 
        {
            "location": "/concept-validation/#usage-example", 
            "text": "In the example below we are defining several validation rules applied to the model during its life-cycle through the workflow it is assigned to.  use raoul2000\\workflow\\validation\\WorkflowValidator;\n/**\n * @property integer $id\n * @property string $col_status\n * @property string $title\n * @property string $body\n * @property string $category\n * @property string $tags\n */\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        // declare the SimpleWorkflowBehavior.\n        return [\n            'workflow' =  [\n                'class' =  \\raoul2000\\workflow\\base\\SimpleWorkflowBehavior::className(),\n                'defaultWorkflowId'      =  'post',\n                'statusAttribute'        =  'col_status',\n                'propagateErrorsToModel' =  true\n            ]\n        ];\n    }\n\n    public function rules()\n    {\n        return [\n            [['col_status'],raoul2000\\workflow\\validation\\WorkflowValidator::className()],\n\n            // rule 1 :  the 'title' is always required\n            ['title','required'],\n\n            // rule 2 : the 'body' is required when the post is about to enter to 'post/correction'\n            [['body'],'required',\n                'on' =  'enter status {post/correction}'],\n\n            // rule 3 : 'category' is set during correction and before publication\n            ['category', 'required',\n                'on' =  'from {post/correction} to {post/published}'\n\n            // rule 4 : 'tags' and 'category' are required before being published or archived.\n            [['tags', 'category'], 'required',\n                'on' =  ['enter status {post/published}', 'enter status {post/archived}']\n            ],          \n        ];\n    }  In the above example we have defined a  Post  model and configured validation rules to implement the following (imaginary) business rules :   rule n\u00b01 : a post must always have a title  : that's a standard one, no workflow magic here  rule n\u00b02 : redactors are not allowed to send a empty post to correction  : attribute  body  is required when the post enters into status  post/correction  rule n\u00b03 : correctors are responsible for setting a category to all post before publishing it  : when a post leaves the 'post/correction  status to go to post/published* it must have the  category  attribute set.  rule n\u00b04 : it is forbidden to publish or archive a post with no tags or no category  : attributes  tags  and  category  cannot be empty when the post\nenter into status  post/published  or  post/archived .", 
            "title": "Usage example"
        }, 
        {
            "location": "/concept-validation/#implementation", 
            "text": "So how does this works ? As you may have guessed, the entry point is the  WorkflowValidator  validator configured for the  status  attribute.\nThis validator is not actually going to validate the attribute it is configured for ! Yes, believe it or not, this validator doesn't care about the current status value or if the model is about to perform a transition that is not permitted : validating transitions is done by the  SimpleWorkflowBehavior  itself, when the model is saved (or when you explicitly invoke  sendToStatus()  on the model) and not by the  WorkflowValidator  validator.  When a model is validated, following occurs :   WorkflowValidator  identifies the pending transition by looking at the  status  attribute value and the current Status  Based on the pending transition, get a  scenario sequence  for each scenario in the scenario sequence, apply corresponding validating rules", 
            "title": "Implementation"
        }, 
        {
            "location": "/workflow-creation/", 
            "text": "Workflow Creation : PHP Source\n\n\nThe way a workflow is defined depends on the \nWorkflow Source\n component we will be using. By default the \nSimpleWorkflowBehavior\n is using an instance of the class \nWorkflowFileSource\n defined in the namespace \nraoul2000\\workflow\\source\\file\n. This component is able to read a workflow definition out of an associative PHP array. In this chapter we are going to learn how to create this array and thus define the craziest workflow ever !! ... humm ok, maybe not really....\n\n\nIdentifiers\n\n\nIdentifiers used for both statuses and workflows are case sensitive \nstrings\n that must start with a letter followed by alpha numerical characters. If you need a delimiter, you can use the minus (-) characters.\n\n\nExample :\n\n\n\n\nvalid Ids : 'post', 'draft', 'PostWorkflow', 'My-workflow', 'published'\n\n\ninvalid Ids : 'my workflow', 'draft mode', '01workflow', 'post_workflow'\n\n\n\n\nNote that status Ids are not aimed to be displayed to the user. For this purpose, we'll see below that you can define a \nlabel\n property accessible through the \ngetLabel()\n method implemented by the Status class.\n\n\nStatus Ids : absolute / relative\n\n\nAn \nabsolute status Id\n is a composite value that includes the id of the workflow that owns the status. The characters slash (/) is used to separate both ids. For example, if we have a status with \"draft\" that belong to the workflow 'PostWorkflow', the absolute status Id is 'PostWorkflow/draft'.\n\n\nA \nrelative status id\n is then simply a value that identifies a status out of any workflow. Based on the previous example, the relative status id would be \"draft\".\n\n\nMost of the time you will not have to deal with absolute status id simply because the \nSimpleWorkflowBehavior\n will try to turn it into its absolute form with the help of the current context. Let's see that on an example :\n\n\n$post = new Post();\n$post-\nstatus = 'published';\n$post-\nsave();\necho $post-\nstatus;\n\n\n\n\nThe output is :\n\n\nPostWorkflow/published\n\n\n\n\nIn this case, the absolute status id has been set to \nPostWorkflow/published\n because the default workflow Id for the Post model is \nPostWorkflow\n and this workflow contains a status 'published' (and this 'published' status is also configured as a \ninitial status\n for the workflow \nPostWorkflow\n).\n\n\nActually, the only cases where you would need to use an absolute status id would be :\n\n\n\n\nwhen you want your model to leave a workflow and go into another workflow (inter-workflow transition)\n\n\nconfigure a default status that doesn't belong to the default workflow\n\n\n\n\nWorkflow Provider\n\n\nBy Default the \nWorkflowFileSource\n component reads workflow definition from \nWorkflow provider\n objects. This type of object  implements the \nIWorkflowDefinitionProvider\n interface which defines a single method : \ngetDefinition()\n. This method must return the actual description of our workflow as a PHP array.\n\n\nPostWorkflow.php in @app/models\n\n\nnamespace app\\models;\nclass PostWorkflow implements raoul2000\\workflow\\base\\IWorkflowDefinitionProvider\n{\n    public function getDefinition() {\n        return [\n            // the workflow definition\n        ];\n    }\n}\n\n\n\n\nLet's see how this workflow definition array must be structured.\n\n\nThe Workflow\n\n\nThe PHP array defining a workflow is an associative array that must contains 2 keys : \ninitialStatusId\n and \nstatus\n.\n\n\n\n\ninitialStatusId\n : \nstring\n that represents the ID of the initial status\n\n\nstatus\n : \narray\n associative array defining each status that belong to the workflow.\n\n\n\n\n[\n    'initialStatusId' =\n 'draft',\n    'status' =\n [\n        // definition of statuses\n    ]\n]\n\n\n\n\nStatus List Definition\n\n\nThe status list definition is an associative array where keys are status Ids and values are status definitions. If a status doesn't need any particular definition, it can be defined directly as a string value.\n\n\nIn the example below, both \ndraft\n and \npusblised\n have a specific definition, but \narchived\n doesn't.\n\n\n[\n    'initialStatusId' =\n 'draft',\n    'status' =\n [\n        'draft'     =\n [ // single status definition ]\n        'published' =\n [ // single status definition ]\n        'archived'\n    ]\n]\n\n\n\n\nSingle Status Definition\n\n\nA Single Status Definition is an associative array that may contains 2 specific keys : \ntransition\n and \nlabel\n\n\n\n\ntransition\n : \narray|string\n list of ids for all statuses that can be reached\n\n\nlabel\n : \nstring\n user friendly name. If not set, the label is automatically created from the status Id.\n\n\n\n\n[\n    'initialStatusId' =\n 'draft',\n    'status' =\n [\n        'draft'     =\n [\n            'label'      =\n 'Draft State'\n            'transition' =\n // transitions definition\n        ]\n    ]\n]\n\n\n\n\nTransition Definition\n\n\nA Transition Definition is an array or a string defining the list of status that can be reached from the current status. In the example below, we are defining a workflow with following transitions:\n\n\n\n\ndraft -\n published\n\n\npublished -\n draft\n\n\npublished -\n archived\n\n\n\n\nAs you can see, there is no transition that leaves the status \narchived\n. Once an item reaches this status it will never move to another status again: \narchived\n is called a \nfinal status\n.\n\n\n[\n    'initialStatusId' =\n 'draft',\n    'status' =\n [\n        'draft'     =\n [\n            'label'      =\n 'Draft State'\n            'transition' =\n 'published'\n        ],\n        'published' =\n [\n            'transition' =\n ['draft','published']\n        ],\n        'archived'\n    ]\n]\n\n\n\n\nAlternatively you can also use a comma separated list of status Id to define a transition. For example, transitions for the \npublished\n status above  could also be written this way :\n\n\n'published' =\n [\n    'transition' =\n 'draft, published'\n]\n\n\n\n\nIn the case you need to configured a transition that targets another workflow, you must use a status id in its  \nabsolute\n form. For example :\n\n\n'published' =\n [\n    'transition' =\n 'draft, anotherWorkflow/toPrint'\n]\n\n\n\n\nMetadata\n\n\nOk, we are now able to create workflows and we can define statuses and transitions between those statuses. As you  can see, the minimum attributes for a status is its \nid\n and optionally we can set a \nlabel\n, but that's all. Well, that's not a lot. What if I need to add more properties to my statuses ? Like for instance it could be nice to associate a color with each status, and display this color to the user (users like colors). The solution is \nmetadata\n.\n\n\nThe \nmetadata\n allows you to add almost any attribute not only to statuses, but also to workflow and transition. Let's see that on an example where we are going to add a \ncolor\n and an \nicon\n metadata to the \npublished\n status.\n\n\n'published' =\n [\n    'metadata' =\n [\n        'color' =\n 'green',\n        'icon'  =\n 'glyphicon glyphicon-pencil'\n    ]\n]\n\n\n\n\nLater on we will be able to retrieve these value of course, and use them the way we want (for instance with a nice and colorful display).\n\n\nExample\n\n\nAs an example we will use our Post workflow designed earlier to manage our publishing platform web app.\n\n\n\n\nBelow is the definition of this workflow ready to be used by the \nSimpleWorkflow\n behavior.\n\n\nnamespace app\\models;\n\nclass PostWorkflow implements raoul2000\\workflow\\base\\IWorkflowDefinitionProvider\n{\n    public function getDefinition() {\n        return [\n            'initialStatusId' =\n 'draft',\n            'status' =\n [\n                'draft' =\n [\n                    'label'      =\n 'Draft Document',\n                    'transition' =\n ['correction']\n                    'metadata'   =\n [\n                        'color' =\n 'yellow'\n                    ]\n                ],\n                'correction' =\n [\n                    'transition' =\n ['draft', 'ready'],\n                    'metadata'   =\n [\n                        'color' =\n 'grey'\n                    ]\n                ],\n                'ready' =\n [\n                    'transition' =\n ['draft', 'correction', 'published'],\n                    'metadata'   =\n [\n                        'color' =\n 'blue'\n                    ]\n                ],\n                'published' =\n [\n                    'transition' =\n ['ready', 'archived'],\n                    'metadata'   =\n [\n                        'color' =\n 'green'\n                    ]                   \n                ],\n                'archived' =\n [\n                    'transition' =\n ['ready'],\n                    'metadata'   =\n [\n                        'color' =\n 'black'\n                    ]                       \n                ]\n            ]\n        ];\n    }\n}", 
            "title": "Defining a workflow"
        }, 
        {
            "location": "/workflow-creation/#workflow-creation-php-source", 
            "text": "The way a workflow is defined depends on the  Workflow Source  component we will be using. By default the  SimpleWorkflowBehavior  is using an instance of the class  WorkflowFileSource  defined in the namespace  raoul2000\\workflow\\source\\file . This component is able to read a workflow definition out of an associative PHP array. In this chapter we are going to learn how to create this array and thus define the craziest workflow ever !! ... humm ok, maybe not really....", 
            "title": "Workflow Creation : PHP Source"
        }, 
        {
            "location": "/workflow-creation/#identifiers", 
            "text": "Identifiers used for both statuses and workflows are case sensitive  strings  that must start with a letter followed by alpha numerical characters. If you need a delimiter, you can use the minus (-) characters.  Example :   valid Ids : 'post', 'draft', 'PostWorkflow', 'My-workflow', 'published'  invalid Ids : 'my workflow', 'draft mode', '01workflow', 'post_workflow'   Note that status Ids are not aimed to be displayed to the user. For this purpose, we'll see below that you can define a  label  property accessible through the  getLabel()  method implemented by the Status class.", 
            "title": "Identifiers"
        }, 
        {
            "location": "/workflow-creation/#status-ids-absolute-relative", 
            "text": "An  absolute status Id  is a composite value that includes the id of the workflow that owns the status. The characters slash (/) is used to separate both ids. For example, if we have a status with \"draft\" that belong to the workflow 'PostWorkflow', the absolute status Id is 'PostWorkflow/draft'.  A  relative status id  is then simply a value that identifies a status out of any workflow. Based on the previous example, the relative status id would be \"draft\".  Most of the time you will not have to deal with absolute status id simply because the  SimpleWorkflowBehavior  will try to turn it into its absolute form with the help of the current context. Let's see that on an example :  $post = new Post();\n$post- status = 'published';\n$post- save();\necho $post- status;  The output is :  PostWorkflow/published  In this case, the absolute status id has been set to  PostWorkflow/published  because the default workflow Id for the Post model is  PostWorkflow  and this workflow contains a status 'published' (and this 'published' status is also configured as a  initial status  for the workflow  PostWorkflow ).  Actually, the only cases where you would need to use an absolute status id would be :   when you want your model to leave a workflow and go into another workflow (inter-workflow transition)  configure a default status that doesn't belong to the default workflow", 
            "title": "Status Ids : absolute / relative"
        }, 
        {
            "location": "/workflow-creation/#workflow-provider", 
            "text": "By Default the  WorkflowFileSource  component reads workflow definition from  Workflow provider  objects. This type of object  implements the  IWorkflowDefinitionProvider  interface which defines a single method :  getDefinition() . This method must return the actual description of our workflow as a PHP array.  PostWorkflow.php in @app/models  namespace app\\models;\nclass PostWorkflow implements raoul2000\\workflow\\base\\IWorkflowDefinitionProvider\n{\n    public function getDefinition() {\n        return [\n            // the workflow definition\n        ];\n    }\n}  Let's see how this workflow definition array must be structured.", 
            "title": "Workflow Provider"
        }, 
        {
            "location": "/workflow-creation/#the-workflow", 
            "text": "The PHP array defining a workflow is an associative array that must contains 2 keys :  initialStatusId  and  status .   initialStatusId  :  string  that represents the ID of the initial status  status  :  array  associative array defining each status that belong to the workflow.   [\n    'initialStatusId' =  'draft',\n    'status' =  [\n        // definition of statuses\n    ]\n]", 
            "title": "The Workflow"
        }, 
        {
            "location": "/workflow-creation/#status-list-definition", 
            "text": "The status list definition is an associative array where keys are status Ids and values are status definitions. If a status doesn't need any particular definition, it can be defined directly as a string value.  In the example below, both  draft  and  pusblised  have a specific definition, but  archived  doesn't.  [\n    'initialStatusId' =  'draft',\n    'status' =  [\n        'draft'     =  [ // single status definition ]\n        'published' =  [ // single status definition ]\n        'archived'\n    ]\n]", 
            "title": "Status List Definition"
        }, 
        {
            "location": "/workflow-creation/#single-status-definition", 
            "text": "A Single Status Definition is an associative array that may contains 2 specific keys :  transition  and  label   transition  :  array|string  list of ids for all statuses that can be reached  label  :  string  user friendly name. If not set, the label is automatically created from the status Id.   [\n    'initialStatusId' =  'draft',\n    'status' =  [\n        'draft'     =  [\n            'label'      =  'Draft State'\n            'transition' =  // transitions definition\n        ]\n    ]\n]", 
            "title": "Single Status Definition"
        }, 
        {
            "location": "/workflow-creation/#transition-definition", 
            "text": "A Transition Definition is an array or a string defining the list of status that can be reached from the current status. In the example below, we are defining a workflow with following transitions:   draft -  published  published -  draft  published -  archived   As you can see, there is no transition that leaves the status  archived . Once an item reaches this status it will never move to another status again:  archived  is called a  final status .  [\n    'initialStatusId' =  'draft',\n    'status' =  [\n        'draft'     =  [\n            'label'      =  'Draft State'\n            'transition' =  'published'\n        ],\n        'published' =  [\n            'transition' =  ['draft','published']\n        ],\n        'archived'\n    ]\n]  Alternatively you can also use a comma separated list of status Id to define a transition. For example, transitions for the  published  status above  could also be written this way :  'published' =  [\n    'transition' =  'draft, published'\n]  In the case you need to configured a transition that targets another workflow, you must use a status id in its   absolute  form. For example :  'published' =  [\n    'transition' =  'draft, anotherWorkflow/toPrint'\n]", 
            "title": "Transition Definition"
        }, 
        {
            "location": "/workflow-creation/#metadata", 
            "text": "Ok, we are now able to create workflows and we can define statuses and transitions between those statuses. As you  can see, the minimum attributes for a status is its  id  and optionally we can set a  label , but that's all. Well, that's not a lot. What if I need to add more properties to my statuses ? Like for instance it could be nice to associate a color with each status, and display this color to the user (users like colors). The solution is  metadata .  The  metadata  allows you to add almost any attribute not only to statuses, but also to workflow and transition. Let's see that on an example where we are going to add a  color  and an  icon  metadata to the  published  status.  'published' =  [\n    'metadata' =  [\n        'color' =  'green',\n        'icon'  =  'glyphicon glyphicon-pencil'\n    ]\n]  Later on we will be able to retrieve these value of course, and use them the way we want (for instance with a nice and colorful display).", 
            "title": "Metadata"
        }, 
        {
            "location": "/workflow-creation/#example", 
            "text": "As an example we will use our Post workflow designed earlier to manage our publishing platform web app.   Below is the definition of this workflow ready to be used by the  SimpleWorkflow  behavior.  namespace app\\models;\n\nclass PostWorkflow implements raoul2000\\workflow\\base\\IWorkflowDefinitionProvider\n{\n    public function getDefinition() {\n        return [\n            'initialStatusId' =  'draft',\n            'status' =  [\n                'draft' =  [\n                    'label'      =  'Draft Document',\n                    'transition' =  ['correction']\n                    'metadata'   =  [\n                        'color' =  'yellow'\n                    ]\n                ],\n                'correction' =  [\n                    'transition' =  ['draft', 'ready'],\n                    'metadata'   =  [\n                        'color' =  'grey'\n                    ]\n                ],\n                'ready' =  [\n                    'transition' =  ['draft', 'correction', 'published'],\n                    'metadata'   =  [\n                        'color' =  'blue'\n                    ]\n                ],\n                'published' =  [\n                    'transition' =  ['ready', 'archived'],\n                    'metadata'   =  [\n                        'color' =  'green'\n                    ]                   \n                ],\n                'archived' =  [\n                    'transition' =  ['ready'],\n                    'metadata'   =  [\n                        'color' =  'black'\n                    ]                       \n                ]\n            ]\n        ];\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/source-file/", 
            "text": "Introduction\n\n\nThe workflow file source component reads workflow definitions from files, and provide \nStatus\n, \nWorkflow\n and \nTransition\n objects. It is not usually accessed directly but though the \nSimpleWorkflowBehavior\n who loads it by default.\n\n\nTo be able to handle various file formats, the \nWorkflowFileSource\n component relies on a module architecture where the task of \nlocating and loading a file\n is delegated to a class implementing the \nWorkflowDefinitionLoader\n interface. There are currently 3 types of workflow definition loader available with yii2-workflow:\n\n\n\n\nPhpClassLoader\n : loads the workflow definition from a class that implements the \nIWorkflowDefinitionProvider\n interface. This is\nthe default loader\n used by the file source component.\n\n\nPhpArrayLoader\n : loads the workflow definition from a PHP file that must returns a PHP array representing the workflow definition.\n\n\nGraphmlLoader\n : loads the workflow definition from a \nGraphml\n file.\n\n\n\n\nThe two first loader are somewhat equivalent in the way they expect to read workflow definition: they both expected to get a PHP array with the same structure. On the other side, the \nGraphmlLoader\n expects to read an XML file.\n\n\nWorkflow definition as PHP Array\n\n\nBoth \nPhpClassLoader\n (default loader) and \nPhpArrayLoader\n expect to read workflow definition from a PHP array. For a complete description of the expected array format, please refer to the chapter \nDefining a Workflow\n.\n\n\nThis array can be stored as a file or provided by a PHP class.\n\n\nPHP class loader\n\n\nBy default\n, the Workflow source file component uses a \nPhpClassLoader\n that allows you to define your workflow as a PHP class. This class is expected to have the same name as the workflow id, and belong to a namespace.\n\n\nNamespace : workflow location\n\n\nBy default the \nPhpClassLoader\n component loads workflows from the \napp\\models\n namespace. So for example in the following declaration, the default workflow associated with the \nPost\n model will be loaded from the class \napp\\models\\MyWorkflow\n :\n\n\nnamespace app\\models;\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =\n '\\raoul2000\\workflow\\base\\SimpleWorkflowBehavior',\n                'defaultWorkflowId' =\n 'MyWorkflow'\n            ]\n        ];\n    }\n}\n\n\n\n\nChanging the workflow definition class namespace\n\n\nIf you need to change the default namespace value you have two options : the fast one and the not so fast one.\n\n\nStandard\n\n\nIn general if you need to change any configuration setting, you must explicitly declare it as a Yii2 application component and not rely on \nSimpleworkflowBehavior\n to do it for you. In the example below, we are defining the source component using the default Id (\nworkflowSource\n)\nand set the namespace used by \nPhpClassLoader\n to the location where workflow definitions are supposed to be located (here \n@app/models/workflows\n).\n\n\n$config = [\n    'components' =\n [\n        'workflowSource' =\n [\n          'class' =\n 'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionLoader' =\n [\n              'class' =\n 'raoul2000\\workflow\\source\\file\\PhpClassLoader',\n              'namespace'  =\n '@app/models/workflows'\n           ]\n        ],\n\n\n\n\nAs you may have guessed, \nthere is only one namespace per workflow source\n component so you are encouraged to locate all your workflows in the same namespace. In the case you must load workflows from various location, you should declare another workflow source component (one per namespace) but remember that each workflow source component serves workflows from only one namespace (folder).\n\n\nThe magic alias\n\n\nAs the \nPhpClassLoader\n is the default loader used with the default source component, it is a common task to change the namespace value used to load PHP classes. Consequently having to explicitly declare component just to change one configuration setting is too much work (and we know good developers are lazy). For this purpose the alias \n@workflowDefinitionNamespace\n is available to define globally the namespace value.\n\n\nFor instance, in you \nindex.php\n file, declare this alias :\n\n\nYii::setAlias('@workflowDefinitionNamespace','app\\\\models\\\\workflows');\n\n\n\n\nBy doing so, \nall workflow definition classes\n will be loaded from the \napp\\models\\workflows\n namespace. Note that this alias overrides any specific namespace configuration that you may have defined the \nstandard ways\n.\n\n\nPHP array Loader\n\n\nThe \nPhpArrayLoader\n loads the workflow definitions from a PHP array stored in a file. As it is not the default loader, you must do some configuration to be able to use it. As you don't want to rely on the default behavior, you must explicitly configure the workflow file source component so to use the \nPHPArrayLoader\n class. In the example below, the workflow definition files are assumed to be located in \n@app/models/workflows\n.\n\n\n$config = [\n    'components' =\n [\n        'workflowSource' =\n [\n          'class' =\n 'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionLoader' =\n [\n              'class' =\n 'raoul2000\\workflow\\source\\file\\PhpArrayLoader',\n              'path'  =\n '@app/models/workflows'\n           ]\n        ],\n\n\n\n\nNow if we want to create the definition for the workflow \npost\n, we just create the file \npost.php\n in the folder \n@app/models/workflows\n.\n\n\nreturn [\n    'initialStatusId' =\n 'draft',\n    'status' =\n [\n        'draft' =\n [\n            'transition' =\n ['publish','deleted']\n        ],\n        'publish' =\n [\n            'transition' =\n ['draft','deleted']\n        ],\n        'deleted' =\n [\n            'transition' =\n ['draft']\n        ]\n    ]\n];\n\n\n\n\nWorkflow definition as Graphml file\n\n\nLoading workflow definition from  \ngraphml\n files.\n\n\nFrom the \nThe GraphML File Format\n web site :\n\n\n\n\nGraphML is a comprehensive and easy-to-use file format for graphs. It consists of a language core to describe the structural properties of a graph and a flexible extension mechanism to add application-specific data.\n\n\n\n\nGraphml file can be generated by various graph design applications like \nyEd\n (that I use).\n\n\nBefore being able to load a \nGraphml\n file, you must ensure that following requirements are met :\n\n\n\n\nnodes labels are assigned to status Id and all nodes must have a label (i.e. all status must have an id)\n\n\na custom property called \ninitialStatusId\n must be added to the workflow and assigned with a valid status Id\n\n\n\n\n$config = [\n    'components' =\n [\n        'workflowSource' =\n [\n          'class' =\n 'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionLoader' =\n [\n              'class' =\n 'raoul2000\\workflow\\source\\file\\GraphmlLoader',\n              'path'  =\n '@app/models/workflows'\n           ]\n        ],\n\n\n\n\nUsing yEd\n\n\n\n\nyEd is a powerful desktop application that can be used to quickly and effectively generate high-quality diagrams.\n\n\n\n\nWith this (free) application you can create a workflow and save it as a \ngraphml\n file that can be used as a source for \nSimpleWorkflow\n. This is interesting in particular if you have to deal with big workflows made of more than 10 status, with plenty of transitions that make it\nlook like a plate of spaghetti.\n\n\nThe only tricky thing is that you must define the \ncustom\n property initialStatusId that is required by \nSimpleWorkflow\n. This can be done easily :\n\n\n\n\ncreate a new empty document\n\n\nclick \nEdit \n Manage Custom Properties ...\n\n\nin the \"Graph Properties\" table, click on the \"Add a New property\" button (green plus sign)\n\n\nset \ninitialStatusId\n as name and leave type as default (text)\n\n\nclose the dialog box\n\n\n\n\nYou're ready to go ! Once your workflow is ready to be used with \nSimpleWorkflow\n make sure that you have assigned the correct value to the  \ninitialStatusId\n custom property. To do so, unselect any item and press \nF6\n key (or select \nEdit \n Property...\n from the menu).\nIn the property dialog box, select the \ndata\n panel, and enter the value of the \ninitialStatusId\n in the appropriate text control. Validate with ok.\n\n\n\n\nYour workflow is now ready to be used as a workflow source by \nSimpleWorkflow\n\n\nCache\n\n\nThe \nWorkflowFileSource\n is able to use a cache component to optimize the workflow definition loading task, that can be significant, in particular with workflows containing a lot of status. Another opportunity to use a cache component is if the workflow definition is provided as a Graphml file. In this such a case, if no cache is used, the \nWorkflowFileSource\n component needs to read and parse the \nGraphml\n file quite often (at least once per request).\n\n\nTo configure a cache component you must use the \ndefinitionCache\n parameter. For example :\n\n\n$config = [\n    'components' =\n [\n        'workflowSource' =\n [\n          'class' =\n 'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionCache' =\n [\n                'class' =\n 'yii\\caching\\FileCache',\n          ],\n        ],\n\n\n\n\nThe cache component must implement \nyii\\caching\\Cache\n. To learn more about Yii2 cache feature, please refer to the \nDefinitive Guide to Yii 2.0\n.\n\n\nNote that the cache is not enabled by default.", 
            "title": "The source file compoent"
        }, 
        {
            "location": "/source-file/#introduction", 
            "text": "The workflow file source component reads workflow definitions from files, and provide  Status ,  Workflow  and  Transition  objects. It is not usually accessed directly but though the  SimpleWorkflowBehavior  who loads it by default.  To be able to handle various file formats, the  WorkflowFileSource  component relies on a module architecture where the task of  locating and loading a file  is delegated to a class implementing the  WorkflowDefinitionLoader  interface. There are currently 3 types of workflow definition loader available with yii2-workflow:   PhpClassLoader  : loads the workflow definition from a class that implements the  IWorkflowDefinitionProvider  interface. This is the default loader  used by the file source component.  PhpArrayLoader  : loads the workflow definition from a PHP file that must returns a PHP array representing the workflow definition.  GraphmlLoader  : loads the workflow definition from a  Graphml  file.   The two first loader are somewhat equivalent in the way they expect to read workflow definition: they both expected to get a PHP array with the same structure. On the other side, the  GraphmlLoader  expects to read an XML file.", 
            "title": "Introduction"
        }, 
        {
            "location": "/source-file/#workflow-definition-as-php-array", 
            "text": "Both  PhpClassLoader  (default loader) and  PhpArrayLoader  expect to read workflow definition from a PHP array. For a complete description of the expected array format, please refer to the chapter  Defining a Workflow .  This array can be stored as a file or provided by a PHP class.", 
            "title": "Workflow definition as PHP Array"
        }, 
        {
            "location": "/source-file/#php-class-loader", 
            "text": "By default , the Workflow source file component uses a  PhpClassLoader  that allows you to define your workflow as a PHP class. This class is expected to have the same name as the workflow id, and belong to a namespace.", 
            "title": "PHP class loader"
        }, 
        {
            "location": "/source-file/#namespace-workflow-location", 
            "text": "By default the  PhpClassLoader  component loads workflows from the  app\\models  namespace. So for example in the following declaration, the default workflow associated with the  Post  model will be loaded from the class  app\\models\\MyWorkflow  :  namespace app\\models;\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class' =  '\\raoul2000\\workflow\\base\\SimpleWorkflowBehavior',\n                'defaultWorkflowId' =  'MyWorkflow'\n            ]\n        ];\n    }\n}", 
            "title": "Namespace : workflow location"
        }, 
        {
            "location": "/source-file/#changing-the-workflow-definition-class-namespace", 
            "text": "If you need to change the default namespace value you have two options : the fast one and the not so fast one.", 
            "title": "Changing the workflow definition class namespace"
        }, 
        {
            "location": "/source-file/#standard", 
            "text": "In general if you need to change any configuration setting, you must explicitly declare it as a Yii2 application component and not rely on  SimpleworkflowBehavior  to do it for you. In the example below, we are defining the source component using the default Id ( workflowSource )\nand set the namespace used by  PhpClassLoader  to the location where workflow definitions are supposed to be located (here  @app/models/workflows ).  $config = [\n    'components' =  [\n        'workflowSource' =  [\n          'class' =  'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionLoader' =  [\n              'class' =  'raoul2000\\workflow\\source\\file\\PhpClassLoader',\n              'namespace'  =  '@app/models/workflows'\n           ]\n        ],  As you may have guessed,  there is only one namespace per workflow source  component so you are encouraged to locate all your workflows in the same namespace. In the case you must load workflows from various location, you should declare another workflow source component (one per namespace) but remember that each workflow source component serves workflows from only one namespace (folder).", 
            "title": "Standard"
        }, 
        {
            "location": "/source-file/#the-magic-alias", 
            "text": "As the  PhpClassLoader  is the default loader used with the default source component, it is a common task to change the namespace value used to load PHP classes. Consequently having to explicitly declare component just to change one configuration setting is too much work (and we know good developers are lazy). For this purpose the alias  @workflowDefinitionNamespace  is available to define globally the namespace value.  For instance, in you  index.php  file, declare this alias :  Yii::setAlias('@workflowDefinitionNamespace','app\\\\models\\\\workflows');  By doing so,  all workflow definition classes  will be loaded from the  app\\models\\workflows  namespace. Note that this alias overrides any specific namespace configuration that you may have defined the  standard ways .", 
            "title": "The magic alias"
        }, 
        {
            "location": "/source-file/#php-array-loader", 
            "text": "The  PhpArrayLoader  loads the workflow definitions from a PHP array stored in a file. As it is not the default loader, you must do some configuration to be able to use it. As you don't want to rely on the default behavior, you must explicitly configure the workflow file source component so to use the  PHPArrayLoader  class. In the example below, the workflow definition files are assumed to be located in  @app/models/workflows .  $config = [\n    'components' =  [\n        'workflowSource' =  [\n          'class' =  'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionLoader' =  [\n              'class' =  'raoul2000\\workflow\\source\\file\\PhpArrayLoader',\n              'path'  =  '@app/models/workflows'\n           ]\n        ],  Now if we want to create the definition for the workflow  post , we just create the file  post.php  in the folder  @app/models/workflows .  return [\n    'initialStatusId' =  'draft',\n    'status' =  [\n        'draft' =  [\n            'transition' =  ['publish','deleted']\n        ],\n        'publish' =  [\n            'transition' =  ['draft','deleted']\n        ],\n        'deleted' =  [\n            'transition' =  ['draft']\n        ]\n    ]\n];", 
            "title": "PHP array Loader"
        }, 
        {
            "location": "/source-file/#workflow-definition-as-graphml-file", 
            "text": "Loading workflow definition from   graphml  files.  From the  The GraphML File Format  web site :   GraphML is a comprehensive and easy-to-use file format for graphs. It consists of a language core to describe the structural properties of a graph and a flexible extension mechanism to add application-specific data.   Graphml file can be generated by various graph design applications like  yEd  (that I use).  Before being able to load a  Graphml  file, you must ensure that following requirements are met :   nodes labels are assigned to status Id and all nodes must have a label (i.e. all status must have an id)  a custom property called  initialStatusId  must be added to the workflow and assigned with a valid status Id   $config = [\n    'components' =  [\n        'workflowSource' =  [\n          'class' =  'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionLoader' =  [\n              'class' =  'raoul2000\\workflow\\source\\file\\GraphmlLoader',\n              'path'  =  '@app/models/workflows'\n           ]\n        ],", 
            "title": "Workflow definition as Graphml file"
        }, 
        {
            "location": "/source-file/#using-yed", 
            "text": "yEd is a powerful desktop application that can be used to quickly and effectively generate high-quality diagrams.   With this (free) application you can create a workflow and save it as a  graphml  file that can be used as a source for  SimpleWorkflow . This is interesting in particular if you have to deal with big workflows made of more than 10 status, with plenty of transitions that make it\nlook like a plate of spaghetti.  The only tricky thing is that you must define the  custom  property initialStatusId that is required by  SimpleWorkflow . This can be done easily :   create a new empty document  click  Edit   Manage Custom Properties ...  in the \"Graph Properties\" table, click on the \"Add a New property\" button (green plus sign)  set  initialStatusId  as name and leave type as default (text)  close the dialog box   You're ready to go ! Once your workflow is ready to be used with  SimpleWorkflow  make sure that you have assigned the correct value to the   initialStatusId  custom property. To do so, unselect any item and press  F6  key (or select  Edit   Property...  from the menu).\nIn the property dialog box, select the  data  panel, and enter the value of the  initialStatusId  in the appropriate text control. Validate with ok.   Your workflow is now ready to be used as a workflow source by  SimpleWorkflow", 
            "title": "Using yEd"
        }, 
        {
            "location": "/source-file/#cache", 
            "text": "The  WorkflowFileSource  is able to use a cache component to optimize the workflow definition loading task, that can be significant, in particular with workflows containing a lot of status. Another opportunity to use a cache component is if the workflow definition is provided as a Graphml file. In this such a case, if no cache is used, the  WorkflowFileSource  component needs to read and parse the  Graphml  file quite often (at least once per request).  To configure a cache component you must use the  definitionCache  parameter. For example :  $config = [\n    'components' =  [\n        'workflowSource' =  [\n          'class' =  'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n          'definitionCache' =  [\n                'class' =  'yii\\caching\\FileCache',\n          ],\n        ],  The cache component must implement  yii\\caching\\Cache . To learn more about Yii2 cache feature, please refer to the  Definitive Guide to Yii 2.0 .  Note that the cache is not enabled by default.", 
            "title": "Cache"
        }, 
        {
            "location": "/upgrade/", 
            "text": "Upgrading From \nSimpleWorkflow\n 1.x\n\n\nIf you have been using the \nprevious version of \nSimpleWorkflow\n together with Yii 1.x and now want to migrate to Yii2, this chapter is for you. We will focus on the main differences between the previous version of \nSimpleWorkflow\n (v1.x) and this one (v2.x).\n\n\nMain improvements in v2.x aimed to clearly separate the workflow definition in terms of status and transition, from the business logic that implements the way a model is going to behave inside a workflow. By doing so, the same workflow can be easily used by models of different types, each one having its own behavior.  \n\n\nAnother goal was to provide maximum flexibility in the way the developer is going to setup its app architecture. For instance the workflow definition can be embedded in any PHP class that implements the appropriate interface (\nraoul2000\\workflow\\source\\file\\IWorkflowDefinitionProvider\n). Moreover almost all classes can be overloaded and new ones created to implements specific needs not covered by the current version.\n\n\nPrinciples\n\n\nNot that much to say here, as there is no change in the way the \nSimpleWorkflowBehavior\n detects status changes :\n\n\n\n\nOn one side an ActiveRecord's attribute which can be viewed as the future status.\n\n\nOn the other side, the actual status managed internally by the behavior.\n\n\n\n\nA transition is a directed link between to statuses : the \nstart\n and the \nend\n status.  \n\n\nDefinition\n\n\nThe workflow definition required by the [[raoul2000\\workflow\\source\\file\\WorkflowFileSource|WorkflowFileSource]] component differs from previous version :\n\n\n\n\nkey \ninitial\n is replaced by \ninitialStatusId\n\n\nkey \nnode\n is replaced by \nstatus\n\n\nstatus ids are stored as keys of the \nstatus\n array (and not as value of the \nid\n key anymore)\n\n\n\n\nFor more information please refer to \nWorkflow File Source Component\n documentation.\n\n\nWorkflow Tasks\n\n\nDeclaration\n\n\nWorkflow Tasks are not declared anymore in the workflow definition itself. This could create a dependency between the workflow and the model, lie for instance when the workflow tasks was using \n$this\n.\n\n\nImplementation\n\n\nWorkflow task used to be a piece of PHP code associated with a workflow transition and evaluated when this transition was performed. With this new version, \nWorkflow Tasks should be implemented as event handler attached to a \nafter\n event type\n.\n\n\nPlease refer to the \nWorkflow Event\n documentation for more.\n\n\nStatus Constraints\n\n\nDeclaration\n\n\nStatus Constraints are not declared anymore in the workflow definition itself, for the same reason as above.\n\n\nImplementation\n\n\nStatus Constraints used to be a piece of PHP code associated with a status and evaluated as a logical expression \nbefore\n a model enters into this status. If the evaluation returned TRUE, the model can access the status, otherwise the transition is blocked.\n\n\nThe same principles still applies but in v2.x \nstatus constraints should be implemented as event handler attached to a \nbefore\n event type.\n\n\nPlease refer to the \nWorkflow Event\n documentation for more.\n\n\nWorkflow Driven Validation\n\n\nIt is still possible to validate models attributes based on the transition that is done by the model. The principle remains the same : Workflow driven validation is based on dynamic scenario names and their associated validation rules declared in the model.\n\n\nPlease refer to the \nWorkflow Driven Attribute Validation\n documentation for more.\n\n\nEvents\n\n\nThere are no major changes in the way workflow events are managed although the event model has been enhanced to provide more control through event handlers.\n\n\nPlease refer to the \nWorkflow Event\n documentation for more.", 
            "title": "Upgrade from 1.x"
        }, 
        {
            "location": "/upgrade/#upgrading-from-simpleworkflow-1x", 
            "text": "If you have been using the  previous version of  SimpleWorkflow  together with Yii 1.x and now want to migrate to Yii2, this chapter is for you. We will focus on the main differences between the previous version of  SimpleWorkflow  (v1.x) and this one (v2.x).  Main improvements in v2.x aimed to clearly separate the workflow definition in terms of status and transition, from the business logic that implements the way a model is going to behave inside a workflow. By doing so, the same workflow can be easily used by models of different types, each one having its own behavior.    Another goal was to provide maximum flexibility in the way the developer is going to setup its app architecture. For instance the workflow definition can be embedded in any PHP class that implements the appropriate interface ( raoul2000\\workflow\\source\\file\\IWorkflowDefinitionProvider ). Moreover almost all classes can be overloaded and new ones created to implements specific needs not covered by the current version.", 
            "title": "Upgrading From SimpleWorkflow 1.x"
        }, 
        {
            "location": "/upgrade/#principles", 
            "text": "Not that much to say here, as there is no change in the way the  SimpleWorkflowBehavior  detects status changes :   On one side an ActiveRecord's attribute which can be viewed as the future status.  On the other side, the actual status managed internally by the behavior.   A transition is a directed link between to statuses : the  start  and the  end  status.", 
            "title": "Principles"
        }, 
        {
            "location": "/upgrade/#definition", 
            "text": "The workflow definition required by the [[raoul2000\\workflow\\source\\file\\WorkflowFileSource|WorkflowFileSource]] component differs from previous version :   key  initial  is replaced by  initialStatusId  key  node  is replaced by  status  status ids are stored as keys of the  status  array (and not as value of the  id  key anymore)   For more information please refer to  Workflow File Source Component  documentation.", 
            "title": "Definition"
        }, 
        {
            "location": "/upgrade/#workflow-tasks", 
            "text": "", 
            "title": "Workflow Tasks"
        }, 
        {
            "location": "/upgrade/#declaration", 
            "text": "Workflow Tasks are not declared anymore in the workflow definition itself. This could create a dependency between the workflow and the model, lie for instance when the workflow tasks was using  $this .", 
            "title": "Declaration"
        }, 
        {
            "location": "/upgrade/#implementation", 
            "text": "Workflow task used to be a piece of PHP code associated with a workflow transition and evaluated when this transition was performed. With this new version,  Workflow Tasks should be implemented as event handler attached to a  after  event type .  Please refer to the  Workflow Event  documentation for more.", 
            "title": "Implementation"
        }, 
        {
            "location": "/upgrade/#status-constraints", 
            "text": "", 
            "title": "Status Constraints"
        }, 
        {
            "location": "/upgrade/#declaration_1", 
            "text": "Status Constraints are not declared anymore in the workflow definition itself, for the same reason as above.", 
            "title": "Declaration"
        }, 
        {
            "location": "/upgrade/#implementation_1", 
            "text": "Status Constraints used to be a piece of PHP code associated with a status and evaluated as a logical expression  before  a model enters into this status. If the evaluation returned TRUE, the model can access the status, otherwise the transition is blocked.  The same principles still applies but in v2.x  status constraints should be implemented as event handler attached to a  before  event type.  Please refer to the  Workflow Event  documentation for more.", 
            "title": "Implementation"
        }, 
        {
            "location": "/upgrade/#workflow-driven-validation", 
            "text": "It is still possible to validate models attributes based on the transition that is done by the model. The principle remains the same : Workflow driven validation is based on dynamic scenario names and their associated validation rules declared in the model.  Please refer to the  Workflow Driven Attribute Validation  documentation for more.", 
            "title": "Workflow Driven Validation"
        }, 
        {
            "location": "/upgrade/#events", 
            "text": "There are no major changes in the way workflow events are managed although the event model has been enhanced to provide more control through event handlers.  Please refer to the  Workflow Event  documentation for more.", 
            "title": "Events"
        }, 
        {
            "location": "/special-cookbook/", 
            "text": "This page contains a set of \nSimpleWorkflow\n snippets that you may have to deal with someday.\n\n\nInitializing The \nSimpleWorkflowBehavior\n behavior\n\n\nDon't be scared ! most of the time you will not have to use \nall\n the configuration settings like on the following example.\n\n\n@app/models/Post.php\n\n\nclass Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class'                    =\n '\\raoul2000\\workflow\\base\\SimpleWorkflowBehavior',\n\n                // model attribute to store status\n                'statusAttribute'          =\n 'col_status',\n\n                // workflow source component name\n                'source'                   =\n 'my_workflow_source',\n\n                'defaultWorkflowId'        =\n 'MyWorkflow',\n                'statusConverter'          =\n null,\n                'statusAccessor'           =\n null,\n\n                // Event Sequence Component Name\n                'eventSequence'            =\n 'eventSequence',\n\n                'propagateErrorsToModel'   =\n false,\n                'stopOnFirstInvalidEvent'  =\n true,\n            ]\n        ];\n    }\n}\n\n\n\n\nInitializing The \nWorkflowSource\n Component\n\n\nAgain, no worries ! Usually the default Workflow Source component will be just fine to use and you'll probably never have to create such a component.\n\n\n@app/config/web.php\n\n\n$config = [\n    'components' =\n [\n        'my_workflow_source' =\n [\n          'class'            =\n 'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n\n          // Cache component name\n          'definitionCache'  =\n 'cache',\n\n          // load workflow as PHP class from the @app/models/workflows namespace\n          'definitionLoader' =\n [\n              'class'      =\n 'raoul2000\\workflow\\source\\file\\PhpClassLoader',\n              'namespace'  =\n '@app/models/workflows'\n           ],\n\n          // workflow provided by PHP class will be defined as a minimal array\n          'parser'           =\n 'raoul2000\\workflow\\source\\file\\MinimalArrayParser',          \n\n           // we provide our own implementation for simple workflow base objects\n           'classMap'        =\n [\n                self::TYPE_WORKFLOW   =\n 'my\\custom\\implementation\\Workflow',\n                self::TYPE_STATUS     =\n 'my\\custom\\implementation\\Status',\n                self::TYPE_TRANSITION =\n 'my\\custom\\implementation\\Transition'\n            ]\n        ],\n        // .. other app components here ..\n    ]\n];\n\n\n\n\nInsert a Model in A Workflow\n\n\n$post1 = new Post();\n// the safe way : insert into default workflow (defaultWorkflowId)\n$post1-\nenterWorkflow();                // the status change is done here\n$post1-\nsave();\n\n$post2 = new Post();\n// the safe way : insert into specific workflow\n$post2-\nenterWorkflow('myWorkflow');    // the status change is done here\n$post2-\nsave();\n\n// the not-so-safe way\n$post3 = new Post();\n$post3-\nstatus = 'Post/draft';          // must be initial status Id\n$post3-\nsave();                         // the status change is done here\n\n\n\n\n\nGetting The Current Status Of a Model\n\n\n$post = Post::findOne(['id' =\n 42]);\n\nif( $post-\nhasWorkflowStatus()) {\n\n    // the safe way\n    echo 'status id    = ' . $post-\ngetWorkflowStatus()-\ngetId();\n    echo 'status label = ' . $post-\ngetWorkflowStatus()-\ngetLabel();\n    echo 'status color = ' . $post-\ngetWorkflowStatus()-\ngetMetadata('color');\n\n    // the not so safe way\n    echo 'status = ' . $post-\nstatus;\n}\n\n\n\n\nChanging Status\n\n\n$post1 = Post::find(['id'=\n42]);\n\n// Two steps : assignment + call to save()\n$post1-\nstatus = 'Post/published';\n$post1-\nsave();                         // the status change is done here\n\n$post2 = Post::find(['id'=\n42]);\n\n// One step : call to sendToStatus()\n$post2-\nsendToStatus('Post/published');     // the status change is done here\n$post-\nsave();\n\n\n\n\nLeaving A Workflow\n\n\n$post1 = Post::find(['id'=\n42]);\n\n// Two steps : assignment + call to save()\n$post1-\nstatus = null;\n$post1-\nsave();                         // the status change is done here\n\n$post2 = Post::find(['id'=\n42]);\n\n// One step : call to sendToStatus()\n$post2-\nsendToStatus(null);             // the status change is done here\n$post-\nsave();\n\n\n\n\nComparing Two Statuses\n\n\n// the usual way : compare status ids\n$post-\ngetWorkflowStatus()-\ngetId() == $otherPost-\ngetWorkflowStatus()-\ngetId();\n\n// the lazy way\n$post-\nstatusEquals($otherPost-\ngetWorkflowStatus());\n\n\n\n\nGetting The WorkflowSource Used By A Model\n\n\n$workflowSource = $post-\ngetWorkflowSource();\n\n\n\n\nUse a reference to the Workflow Source to access the workflow directly (not through the model).\n\n\nLooping on all Next Statuses\n\n\nask the Status Object\n\n\n$post = Post::find(['id'=\n42]);\n\nif( $post-\nhasWorkflowStatus()) {\n\n    // let's ask the Status object then\n    $transitions = $post\n        -\ngetWorkflowStatus()\n        -\ngetTransitions();\n\n    foreach( $transitions as $transition ) {\n        echo $transition-\ngetEndStatus()-\ngetId();\n    }\n}\n\n\n\n\nThrough the Workflow Source\n\n\n$post = Post::find(['id'=\n42]);\n\nif( $post-\nhasWorkflowStatus()) {\n\n    // ask the WorkflowSource\n    $transitions = $post\n        -\ngetWorkflowSource()\n        -\ngetTransitions($post-\ngetWorkflowStatus()-\ngetId());\n\n    foreach( $transitions as $transition ) {\n        echo $transition-\ngetEndStatus()-\ngetId();\n    }\n}\n\n\n\n\nUse the ChangeStatusAction\n\n\nSince version 1.1.0 it is possible to change the workflow of a model using a \nStandalone Action\n ready to use in your controller. To do so you must declare the action and provide 2 callable variables :\n\n\n\n\nfindModel\n : return the model from its id\n\n\nresponse\n : customize the response\n\n\n\n\nHere is an example of a controller class using the \nChangeStatus\n action :\n\n\nnamespace app\\controllers\\workflow;\n\nuse Yii;\nuse yii\\web\\Controller;\nuse app\\models\\Post;\nuse yii\\web\\NotFoundHttpException;\n\n\nclass WorkflowController extends Controller\n{\n    public function actions()\n    {\n            return [\n                    'change' =\n [\n                        'class' =\n 'app\\actions\\workflow\\ChangeStatusAction',\n                        'findModel' =\n [$this, 'findModel'],\n                        'response'  =\n [$this, 'response']\n                    ]\n            ];\n    }\n\n    public function response($changedStatus, $model) {\n        return $changeStatus;\n    }\n\n  public function findModel($id)\n  {\n    if (($model = Post::findOne($id)) !== null) {\n        return $model;\n    } else {\n        throw new NotFoundHttpException('The requested page does not exist.');\n    }\n  }\n}", 
            "title": "Cookbook"
        }, 
        {
            "location": "/special-cookbook/#initializing-the-simpleworkflowbehavior-behavior", 
            "text": "Don't be scared ! most of the time you will not have to use  all  the configuration settings like on the following example.  @app/models/Post.php  class Post extends \\yii\\db\\ActiveRecord\n{\n    public function behaviors()\n    {\n        return [\n            [\n                'class'                    =  '\\raoul2000\\workflow\\base\\SimpleWorkflowBehavior',\n\n                // model attribute to store status\n                'statusAttribute'          =  'col_status',\n\n                // workflow source component name\n                'source'                   =  'my_workflow_source',\n\n                'defaultWorkflowId'        =  'MyWorkflow',\n                'statusConverter'          =  null,\n                'statusAccessor'           =  null,\n\n                // Event Sequence Component Name\n                'eventSequence'            =  'eventSequence',\n\n                'propagateErrorsToModel'   =  false,\n                'stopOnFirstInvalidEvent'  =  true,\n            ]\n        ];\n    }\n}", 
            "title": "Initializing The SimpleWorkflowBehavior behavior"
        }, 
        {
            "location": "/special-cookbook/#initializing-the-workflowsource-component", 
            "text": "Again, no worries ! Usually the default Workflow Source component will be just fine to use and you'll probably never have to create such a component.  @app/config/web.php  $config = [\n    'components' =  [\n        'my_workflow_source' =  [\n          'class'            =  'raoul2000\\workflow\\source\\file\\WorkflowFileSource',\n\n          // Cache component name\n          'definitionCache'  =  'cache',\n\n          // load workflow as PHP class from the @app/models/workflows namespace\n          'definitionLoader' =  [\n              'class'      =  'raoul2000\\workflow\\source\\file\\PhpClassLoader',\n              'namespace'  =  '@app/models/workflows'\n           ],\n\n          // workflow provided by PHP class will be defined as a minimal array\n          'parser'           =  'raoul2000\\workflow\\source\\file\\MinimalArrayParser',          \n\n           // we provide our own implementation for simple workflow base objects\n           'classMap'        =  [\n                self::TYPE_WORKFLOW   =  'my\\custom\\implementation\\Workflow',\n                self::TYPE_STATUS     =  'my\\custom\\implementation\\Status',\n                self::TYPE_TRANSITION =  'my\\custom\\implementation\\Transition'\n            ]\n        ],\n        // .. other app components here ..\n    ]\n];", 
            "title": "Initializing The WorkflowSource Component"
        }, 
        {
            "location": "/special-cookbook/#insert-a-model-in-a-workflow", 
            "text": "$post1 = new Post();\n// the safe way : insert into default workflow (defaultWorkflowId)\n$post1- enterWorkflow();                // the status change is done here\n$post1- save();\n\n$post2 = new Post();\n// the safe way : insert into specific workflow\n$post2- enterWorkflow('myWorkflow');    // the status change is done here\n$post2- save();\n\n// the not-so-safe way\n$post3 = new Post();\n$post3- status = 'Post/draft';          // must be initial status Id\n$post3- save();                         // the status change is done here", 
            "title": "Insert a Model in A Workflow"
        }, 
        {
            "location": "/special-cookbook/#getting-the-current-status-of-a-model", 
            "text": "$post = Post::findOne(['id' =  42]);\n\nif( $post- hasWorkflowStatus()) {\n\n    // the safe way\n    echo 'status id    = ' . $post- getWorkflowStatus()- getId();\n    echo 'status label = ' . $post- getWorkflowStatus()- getLabel();\n    echo 'status color = ' . $post- getWorkflowStatus()- getMetadata('color');\n\n    // the not so safe way\n    echo 'status = ' . $post- status;\n}", 
            "title": "Getting The Current Status Of a Model"
        }, 
        {
            "location": "/special-cookbook/#changing-status", 
            "text": "$post1 = Post::find(['id'= 42]);\n\n// Two steps : assignment + call to save()\n$post1- status = 'Post/published';\n$post1- save();                         // the status change is done here\n\n$post2 = Post::find(['id'= 42]);\n\n// One step : call to sendToStatus()\n$post2- sendToStatus('Post/published');     // the status change is done here\n$post- save();", 
            "title": "Changing Status"
        }, 
        {
            "location": "/special-cookbook/#leaving-a-workflow", 
            "text": "$post1 = Post::find(['id'= 42]);\n\n// Two steps : assignment + call to save()\n$post1- status = null;\n$post1- save();                         // the status change is done here\n\n$post2 = Post::find(['id'= 42]);\n\n// One step : call to sendToStatus()\n$post2- sendToStatus(null);             // the status change is done here\n$post- save();", 
            "title": "Leaving A Workflow"
        }, 
        {
            "location": "/special-cookbook/#comparing-two-statuses", 
            "text": "// the usual way : compare status ids\n$post- getWorkflowStatus()- getId() == $otherPost- getWorkflowStatus()- getId();\n\n// the lazy way\n$post- statusEquals($otherPost- getWorkflowStatus());", 
            "title": "Comparing Two Statuses"
        }, 
        {
            "location": "/special-cookbook/#getting-the-workflowsource-used-by-a-model", 
            "text": "$workflowSource = $post- getWorkflowSource();  Use a reference to the Workflow Source to access the workflow directly (not through the model).", 
            "title": "Getting The WorkflowSource Used By A Model"
        }, 
        {
            "location": "/special-cookbook/#looping-on-all-next-statuses", 
            "text": "", 
            "title": "Looping on all Next Statuses"
        }, 
        {
            "location": "/special-cookbook/#ask-the-status-object", 
            "text": "$post = Post::find(['id'= 42]);\n\nif( $post- hasWorkflowStatus()) {\n\n    // let's ask the Status object then\n    $transitions = $post\n        - getWorkflowStatus()\n        - getTransitions();\n\n    foreach( $transitions as $transition ) {\n        echo $transition- getEndStatus()- getId();\n    }\n}", 
            "title": "ask the Status Object"
        }, 
        {
            "location": "/special-cookbook/#through-the-workflow-source", 
            "text": "$post = Post::find(['id'= 42]);\n\nif( $post- hasWorkflowStatus()) {\n\n    // ask the WorkflowSource\n    $transitions = $post\n        - getWorkflowSource()\n        - getTransitions($post- getWorkflowStatus()- getId());\n\n    foreach( $transitions as $transition ) {\n        echo $transition- getEndStatus()- getId();\n    }\n}", 
            "title": "Through the Workflow Source"
        }, 
        {
            "location": "/special-cookbook/#use-the-changestatusaction", 
            "text": "Since version 1.1.0 it is possible to change the workflow of a model using a  Standalone Action  ready to use in your controller. To do so you must declare the action and provide 2 callable variables :   findModel  : return the model from its id  response  : customize the response   Here is an example of a controller class using the  ChangeStatus  action :  namespace app\\controllers\\workflow;\n\nuse Yii;\nuse yii\\web\\Controller;\nuse app\\models\\Post;\nuse yii\\web\\NotFoundHttpException;\n\n\nclass WorkflowController extends Controller\n{\n    public function actions()\n    {\n            return [\n                    'change' =  [\n                        'class' =  'app\\actions\\workflow\\ChangeStatusAction',\n                        'findModel' =  [$this, 'findModel'],\n                        'response'  =  [$this, 'response']\n                    ]\n            ];\n    }\n\n    public function response($changedStatus, $model) {\n        return $changeStatus;\n    }\n\n  public function findModel($id)\n  {\n    if (($model = Post::findOne($id)) !== null) {\n        return $model;\n    } else {\n        throw new NotFoundHttpException('The requested page does not exist.');\n    }\n  }\n}", 
            "title": "Use the ChangeStatusAction"
        }, 
        {
            "location": "/class-ref/", 
            "text": "Visit the \nClass Reference Documentation\n for a complete description of the \nyii2-workflow\n implementation.\n\n\nUML Diagram\n\n\nview fullscreen", 
            "title": "Class Reference"
        }, 
        {
            "location": "/class-ref/#uml-diagram", 
            "text": "view fullscreen", 
            "title": "UML Diagram"
        }
    ]
}